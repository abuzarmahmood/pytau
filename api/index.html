<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>API - PyTau</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <link href="../assets/_mkdocstrings.css" rel="stylesheet">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">PyTau</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href=".." class="nav-link">Start</a>
                            </li>
                            <li class="nav-item">
                                <a href="../pymc_concepts/" class="nav-link">PyMC Concepts</a>
                            </li>
                            <li class="nav-item">
                                <a href="./" class="nav-link active" aria-current="page">API</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../pymc_concepts/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#references" class="nav-link">References</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#analysis-functions" class="nav-link">=== Analysis functions ===</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_analysis" class="nav-link">changepoint_analysis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_analysis.PklHandler" class="nav-link">PklHandler</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_analysis.calc_significant_neurons_firing" class="nav-link">calc_significant_neurons_firing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_analysis.calc_significant_neurons_snippets" class="nav-link">calc_significant_neurons_snippets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_analysis.get_state_firing" class="nav-link">get_state_firing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_analysis.get_transition_snips" class="nav-link">get_transition_snips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#io-functions" class="nav-link">=== I/O functions ===</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_io" class="nav-link">changepoint_io</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_io.DatabaseHandler" class="nav-link">DatabaseHandler</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_io.FitHandler" class="nav-link">FitHandler</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_io.SimpleApprox" class="nav-link">SimpleApprox</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#model-building-functions" class="nav-link">=== Model building functions ===</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model" class="nav-link">changepoint_model</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.AllTastePoisson" class="nav-link">AllTastePoisson</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.AllTastePoissonTrialSwitch" class="nav-link">AllTastePoissonTrialSwitch</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.AllTastePoissonVarsigFixed" class="nav-link">AllTastePoissonVarsigFixed</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.CategoricalChangepoint2D" class="nav-link">CategoricalChangepoint2D</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.ChangepointModel" class="nav-link">ChangepointModel</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.GaussianChangepointMean2D" class="nav-link">GaussianChangepointMean2D</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.GaussianChangepointMeanDirichlet" class="nav-link">GaussianChangepointMeanDirichlet</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.GaussianChangepointMeanVar2D" class="nav-link">GaussianChangepointMeanVar2D</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.PoissonChangepoint1D" class="nav-link">PoissonChangepoint1D</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.SingleTastePoisson" class="nav-link">SingleTastePoisson</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.SingleTastePoissonDirichlet" class="nav-link">SingleTastePoissonDirichlet</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.SingleTastePoissonTrialSwitch" class="nav-link">SingleTastePoissonTrialSwitch</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.SingleTastePoissonVarsig" class="nav-link">SingleTastePoissonVarsig</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.SingleTastePoissonVarsigFixed" class="nav-link">SingleTastePoissonVarsigFixed</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.advi_fit" class="nav-link">advi_fit</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.all_taste_poisson" class="nav-link">all_taste_poisson</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.all_taste_poisson_trial_switch" class="nav-link">all_taste_poisson_trial_switch</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.all_taste_poisson_varsig_fixed" class="nav-link">all_taste_poisson_varsig_fixed</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.dpp_fit" class="nav-link">dpp_fit</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.extract_inferred_values" class="nav-link">extract_inferred_values</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.find_best_states" class="nav-link">find_best_states</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.gaussian_changepoint_mean_2d" class="nav-link">gaussian_changepoint_mean_2d</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.gaussian_changepoint_mean_dirichlet" class="nav-link">gaussian_changepoint_mean_dirichlet</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.gaussian_changepoint_mean_var_2d" class="nav-link">gaussian_changepoint_mean_var_2d</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.gen_test_array" class="nav-link">gen_test_array</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.mcmc_fit" class="nav-link">mcmc_fit</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.poisson_changepoint_1d" class="nav-link">poisson_changepoint_1d</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.run_all_tests" class="nav-link">run_all_tests</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.single_taste_poisson" class="nav-link">single_taste_poisson</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.single_taste_poisson_dirichlet" class="nav-link">single_taste_poisson_dirichlet</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.single_taste_poisson_trial_switch" class="nav-link">single_taste_poisson_trial_switch</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.single_taste_poisson_varsig" class="nav-link">single_taste_poisson_varsig</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.single_taste_poisson_varsig_fixed" class="nav-link">single_taste_poisson_varsig_fixed</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.var_sig_exp_tt" class="nav-link">var_sig_exp_tt</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_model.var_sig_tt" class="nav-link">var_sig_tt</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#preprocessing-functions" class="nav-link">=== Preprocessing functions ===</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_preprocess" class="nav-link">changepoint_preprocess</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_preprocess.preprocess_all_taste" class="nav-link">preprocess_all_taste</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pytau.changepoint_preprocess.preprocess_single_taste" class="nav-link">preprocess_single_taste</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="references">References</h1>
<h2 id="analysis-functions"><strong>=== Analysis functions ===</strong></h2>


<div class="doc doc-object doc-module">



<a id="pytau.changepoint_analysis"></a>
    <div class="doc doc-contents first">

        <p>Helper classes and functions to perform analysis on fitted models</p>










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_analysis.PklHandler" class="doc doc-heading">
            <code>PklHandler</code>


</h2>


    <div class="doc doc-contents ">



        <p>Helper class to handle metadata and fit data from pkl file</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_analysis.py</code></summary>
                <pre class="highlight"><code class="language-python">class PklHandler:
    """Helper class to handle metadata and fit data from pkl file"""

    def __init__(self, file_path):
        """Initialize PklHandler class

        Args:
            file_path (str): Path to pkl file
        """
        self.dir_name = os.path.dirname(file_path)
        file_name = os.path.basename(file_path)
        self.file_name_base = file_name.split(".")[0]
        self.pkl_file_path = os.path.join(
            self.dir_name, self.file_name_base + ".pkl")
        with open(self.pkl_file_path, "rb") as this_file:
            self.data = pkl.load(this_file)

        model_keys = ["model", "approx", "lambda", "tau", "data"]
        key_savenames = [
            "_model_structure",
            "_fit_model",
            "lambda_array",
            "tau_array",
            "processed_spikes",
        ]
        data_map = dict(zip(model_keys, key_savenames))

        for key, var_name in data_map.items():
            if key in self.data["model_data"]:
                setattr(self, var_name, self.data["model_data"][key])
            else:
                # Set to None if key is missing (e.g., due to pickling fallback)
                setattr(self, var_name, None)

        self.metadata = self.data["metadata"]
        self.pretty_metadata = pd.json_normalize(self.data["metadata"]).T

        # Get number of trials from processed_spikes for proper tau formatting
        n_trials = self.processed_spikes.shape[0] if hasattr(
            self.processed_spikes, 'shape') else None
        self.tau = _tau(self.tau_array, self.metadata, n_trials)
        self.firing = _firing(self.tau, self.processed_spikes, self.metadata)</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_analysis.PklHandler.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(file_path)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize PklHandler class</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>file_path</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to pkl file</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_analysis.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, file_path):
    """Initialize PklHandler class

    Args:
        file_path (str): Path to pkl file
    """
    self.dir_name = os.path.dirname(file_path)
    file_name = os.path.basename(file_path)
    self.file_name_base = file_name.split(".")[0]
    self.pkl_file_path = os.path.join(
        self.dir_name, self.file_name_base + ".pkl")
    with open(self.pkl_file_path, "rb") as this_file:
        self.data = pkl.load(this_file)

    model_keys = ["model", "approx", "lambda", "tau", "data"]
    key_savenames = [
        "_model_structure",
        "_fit_model",
        "lambda_array",
        "tau_array",
        "processed_spikes",
    ]
    data_map = dict(zip(model_keys, key_savenames))

    for key, var_name in data_map.items():
        if key in self.data["model_data"]:
            setattr(self, var_name, self.data["model_data"][key])
        else:
            # Set to None if key is missing (e.g., due to pickling fallback)
            setattr(self, var_name, None)

    self.metadata = self.data["metadata"]
    self.pretty_metadata = pd.json_normalize(self.data["metadata"]).T

    # Get number of trials from processed_spikes for proper tau formatting
    n_trials = self.processed_spikes.shape[0] if hasattr(
        self.processed_spikes, 'shape') else None
    self.tau = _tau(self.tau_array, self.metadata, n_trials)
    self.firing = _firing(self.tau, self.processed_spikes, self.metadata)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_analysis.calc_significant_neurons_firing" class="doc doc-heading">
            <code class="highlight language-python">calc_significant_neurons_firing(state_firing, p_val=0.05)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculate significant changes in firing rate between states
Iterate ANOVA over neurons for all states
With Bonferroni correction</p>
<p>Args
    state_firing (3D Numpy array): trials x states x nrns
    p_val (float, optional): p-value to use for significance. Defaults to 0.05.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>anova_p_val_array</code></td>            <td>
                  <code>1D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>p-values for each neuron</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>anova_sig_neurons</code></td>            <td>
                  <code>1D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>indices of significant neurons</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_analysis.py</code></summary>
              <pre class="highlight"><code class="language-python">def calc_significant_neurons_firing(state_firing, p_val=0.05):
    """Calculate significant changes in firing rate between states
    Iterate ANOVA over neurons for all states
    With Bonferroni correction

    Args
        state_firing (3D Numpy array): trials x states x nrns
        p_val (float, optional): p-value to use for significance. Defaults to 0.05.

    Returns:
        anova_p_val_array (1D Numpy array): p-values for each neuron
        anova_sig_neurons (1D Numpy array): indices of significant neurons
    """
    n_neurons = state_firing.shape[-1]
    # Calculate ANOVA p-values for each neuron
    anova_p_val_array = np.zeros(state_firing.shape[-1])
    for neuron in range(state_firing.shape[-1]):
        anova_p_val_array[neuron] = f_oneway(*state_firing[:, :, neuron].T)[1]
    anova_sig_neurons = np.where(anova_p_val_array &lt; p_val / n_neurons)[0]

    return anova_p_val_array, anova_sig_neurons</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_analysis.calc_significant_neurons_snippets" class="doc doc-heading">
            <code class="highlight language-python">calc_significant_neurons_snippets(transition_snips, p_val=0.05)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculate pairwise t-tests to detect differences between each transition
With Bonferroni correction</p>
<p>Args
    transition_snips (4D Numpy array): trials x nrns x bins x transitions
    p_val (float, optional): p-value to use for significance. Defaults to 0.05.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>anova_p_val_array</code></td>            <td>
                  <code>(<span title="neurons">neurons</span>, <span title="transition">transition</span>)</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>p-values for each neuron</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>anova_sig_neurons</code></td>            <td>
                  <code>(<span title="neurons">neurons</span>, <span title="transition">transition</span>)</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>indices of significant neurons</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_analysis.py</code></summary>
              <pre class="highlight"><code class="language-python">def calc_significant_neurons_snippets(transition_snips, p_val=0.05):
    """Calculate pairwise t-tests to detect differences between each transition
    With Bonferroni correction

    Args
        transition_snips (4D Numpy array): trials x nrns x bins x transitions
        p_val (float, optional): p-value to use for significance. Defaults to 0.05.

    Returns:
        anova_p_val_array (neurons, transition): p-values for each neuron
        anova_sig_neurons (neurons, transition): indices of significant neurons
    """
    # Calculate pairwise t-tests for each transition
    # shape : [before, after] x trials x neurons x transitions
    mean_transition_snips = np.stack(np.array_split(
        transition_snips, 2, axis=2)).mean(axis=3)
    pairwise_p_val_array = np.zeros(mean_transition_snips.shape[2:])
    n_neuron, n_transitions = pairwise_p_val_array.shape
    for neuron in range(n_neuron):
        for transition in range(n_transitions):
            pairwise_p_val_array[neuron, transition] = ttest_rel(
                *mean_transition_snips[:, :, neuron, transition]
            )[1]
    pairwise_sig_neurons = pairwise_p_val_array &lt; p_val  # /n_neuron
    return pairwise_p_val_array, pairwise_sig_neurons</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_analysis.get_state_firing" class="doc doc-heading">
            <code class="highlight language-python">get_state_firing(spike_array, tau_array)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Calculate firing rates within states given changepoint positions on data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spike_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x nrns x bins</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tau_array</code>
            </td>
            <td>
                  <code>2D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x switchpoints</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>state_firing</code></td>            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x states x nrns</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_analysis.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_state_firing(spike_array, tau_array):
    """Calculate firing rates within states given changepoint positions on data

    Args:
        spike_array (3D Numpy array): trials x nrns x bins
        tau_array (2D Numpy array): trials x switchpoints

    Returns:
        state_firing (3D Numpy array): trials x states x nrns
    """

    states = tau_array.shape[-1] + 1
    # Get mean firing rate for each STATE using model
    state_inds = np.hstack(
        [
            np.zeros((tau_array.shape[0], 1)),
            tau_array,
            np.ones((tau_array.shape[0], 1)) * spike_array.shape[-1],
        ]
    )
    state_lims = np.array([state_inds[:, x: x + 2] for x in range(states)])
    state_lims = np.vectorize(int)(state_lims)
    state_lims = np.swapaxes(state_lims, 0, 1)

    state_firing = np.array(
        [
            [np.mean(trial_dat[:, start:end], axis=-1)
             for start, end in trial_lims]
            for trial_dat, trial_lims in zip(spike_array, state_lims)
        ]
    )

    state_firing = np.nan_to_num(state_firing)
    return state_firing</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_analysis.get_transition_snips" class="doc doc-heading">
            <code class="highlight language-python">get_transition_snips(spike_array, tau_array, window_radius=300)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Get snippets of activty around changepoints for each trial</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spike_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x nrns x bins</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tau_array</code>
            </td>
            <td>
                  <code>2D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x switchpoints</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Numpy array: Transition snippets : trials x nrns x bins x transitions</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Make sure none of the snippets are outside the bounds of the data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_analysis.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_transition_snips(spike_array, tau_array, window_radius=300):
    """Get snippets of activty around changepoints for each trial

    Args:
        spike_array (3D Numpy array): trials x nrns x bins
        tau_array (2D Numpy array): trials x switchpoints

    Returns:
        Numpy array: Transition snippets : trials x nrns x bins x transitions

    Make sure none of the snippets are outside the bounds of the data
    """
    # Get snippets of activity around changepoints for each trial
    n_trials, n_neurons, n_bins = spike_array.shape
    n_transitions = tau_array.shape[1]
    transition_snips = np.zeros(
        (n_trials, n_neurons, 2 * window_radius, n_transitions))
    window_lims = np.stack(
        [tau_array - window_radius, tau_array + window_radius], axis=-1)

    # Make sure no lims are outside the bounds of the data
    if (window_lims &lt; 0).sum(axis=None) or (window_lims &gt; n_bins).sum(axis=None):
        raise ValueError("Transition window extends outside data bounds")

    # Pull out snippets
    for trial in range(n_trials):
        for transition in range(n_transitions):
            transition_snips[trial, :, :, transition] = spike_array[
                trial,
                :,
                window_lims[trial, transition, 0]: window_lims[trial, transition, 1],
            ]
    return transition_snips</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="io-functions"><strong>=== I/O functions ===</strong></h2>


<div class="doc doc-object doc-module">



<a id="pytau.changepoint_io"></a>
    <div class="doc doc-contents first">

        <p>Pipeline to handle model fitting from data extraction to saving results</p>










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_io.DatabaseHandler" class="doc doc-heading">
            <code>DatabaseHandler</code>


</h2>


    <div class="doc doc-contents ">



        <p>Class to handle transactions with model database</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
                <pre class="highlight"><code class="language-python">class DatabaseHandler:
    """Class to handle transactions with model database"""

    def __init__(self):
        """Initialize DatabaseHandler class"""
        self.unique_cols = ["exp.model_id", "exp.save_path", "exp.fit_date"]
        self.model_database_path = MODEL_DATABASE_PATH
        self.model_save_base_dir = MODEL_SAVE_DIR

        if os.path.exists(self.model_database_path):
            self.fit_database = pd.read_csv(
                self.model_database_path, index_col=0)
            all_na = [all(x) for num, x in self.fit_database.isna().iterrows()]
            if all_na:
                print(f"{sum(all_na)} rows found with all NA, removing...")
                self.fit_database = self.fit_database.dropna(how="all")
        else:
            print("Fit database does not exist yet")

    def show_duplicates(self, keep="first"):
        """Find duplicates in database

        Args:
            keep (str, optional): Which duplicate to keep
                    (refer to pandas duplicated). Defaults to 'first'.

        Returns:
            pandas dataframe: Dataframe containing duplicated rows
            pandas series : Indices of duplicated rows
        """
        dup_inds = self.fit_database.drop(
            self.unique_cols, axis=1).duplicated(keep=keep)
        return self.fit_database.loc[dup_inds], dup_inds

    def drop_duplicates(self):
        """Remove duplicated rows from database"""
        _, dup_inds = self.show_duplicates()
        print(f"Removing {sum(dup_inds)} duplicate rows")
        self.fit_database = self.fit_database.loc[~dup_inds]

    def check_mismatched_paths(self):
        """Check if there are any mismatched pkl files between database and directory

        Returns:
            pandas dataframe: Dataframe containing rows for which pkl file not present
            list: pkl files which cannot be matched to model in database
            list: all files in save directory
        """
        mismatch_from_database = [
            not os.path.exists(x + ".pkl") for x in self.fit_database["exp.save_path"]
        ]
        file_list = glob(os.path.join(self.model_save_base_dir, "*/*.pkl"))
        # Only split basename by '.' in case there are multiple '.' in filenpath
        mismatch_from_file = [
            not (
                os.path.join(
                    os.path.dirname(x),
                    os.path.basename(x).split(".")[0])
                in list(self.fit_database["exp.save_path"]))
            for x in file_list
        ]
        print(
            f"{sum(mismatch_from_database)} mismatches from database"
            + "\n"
            + f"{sum(mismatch_from_file)} mismatches from files"
        )
        return mismatch_from_database, mismatch_from_file, file_list

    def clear_mismatched_paths(self):
        """Remove mismatched files and rows in database

        i.e. Remove
        1) Files for which no entry can be found in database
        2) Database entries for which no corresponding file can be found
        """
        (
            mismatch_from_database,
            mismatch_from_file,
            file_list,
        ) = self.check_mismatched_paths()
        mismatch_from_file = np.array(mismatch_from_file)
        mismatch_from_database = np.array(mismatch_from_database)
        self.fit_database = self.fit_database.loc[~mismatch_from_database]
        mismatched_files = [x for x, y in zip(
            file_list, mismatch_from_file) if y]
        for x in mismatched_files:
            os.remove(x)
        print("==== Clearing Completed ====")

    def write_updated_database(self):
        """Can be called following clear_mismatched_entries to update current database"""
        database_backup_dir = os.path.join(
            self.model_save_base_dir, ".database_backups")
        if not os.path.exists(database_backup_dir):
            os.makedirs(database_backup_dir)
        # current_date = date.today().strftime("%m-%d-%y")
        current_date = str(datetime.now()).replace(" ", "_")
        shutil.copy(
            self.model_database_path,
            os.path.join(database_backup_dir,
                         f"database_backup_{current_date}"),
        )
        self.fit_database.to_csv(self.model_database_path, mode="w")

    def set_run_params(self, data_dir, experiment_name, taste_num, laser_type, region_name):
        """Store metadata related to inference run

        Args:
            data_dir (str): Path to directory containing HDF5 file
            experiment_name (str): Name given to fitted batch
                    (for metedata). Defaults to None.
            taste_num (int): Index of taste to perform fit on (Corresponds to
                    INDEX of taste in spike array, not actual dig_ins)
            laser_type (None or str): None, 'on', or 'off' (For a laser session,
                    which set of trials are wanted, None indicated return all trials)
            region_name (str): Region on which to perform fit on
                    (must match regions in .info file)
        """
        self.data_dir = data_dir
        self.data_basename = os.path.basename(self.data_dir)
        self.animal_name = self.data_basename.split("_")[0]
        self.session_date = self.data_basename.split("_")[-1]

        self.experiment_name = experiment_name
        self.model_save_dir = os.path.join(
            self.model_save_base_dir, experiment_name)

        if not os.path.exists(self.model_save_dir):
            os.makedirs(self.model_save_dir)

        self.model_id = str(uuid.uuid4()).split("-")[0]
        self.model_save_path = os.path.join(
            self.model_save_dir, self.experiment_name + "_" + self.model_id
        )
        self.fit_date = date.today().strftime("%m-%d-%y")

        self.taste_num = taste_num
        self.laser_type = laser_type
        self.region_name = region_name

        self.fit_exists = None

    def ingest_fit_data(self, met_dict):
        """Load external metadata

        Args:
            met_dict (dict): Dictionary of metadata from FitHandler class
        """
        self.external_metadata = met_dict

    def aggregate_metadata(self):
        """Collects information regarding data and current "experiment"

        Raises:
            Exception: If 'external_metadata' has not been ingested, that needs to be done first

        Returns:
            dict: Dictionary of metadata given to FitHandler class
        """
        if "external_metadata" not in dir(self):
            raise Exception(
                "Fit run metdata needs to be ingested " "into data_handler first")

        data_details = dict(
            zip(
                [
                    "data_dir",
                    "basename",
                    "animal_name",
                    "session_date",
                    "taste_num",
                    "laser_type",
                    "region_name",
                ],
                [
                    self.data_dir,
                    self.data_basename,
                    self.animal_name,
                    self.session_date,
                    self.taste_num,
                    self.laser_type,
                    self.region_name,
                ],
            )
        )

        exp_details = dict(
            zip(
                ["exp_name", "model_id", "save_path", "fit_date"],
                [
                    self.experiment_name,
                    self.model_id,
                    self.model_save_path,
                    self.fit_date,
                ],
            )
        )

        module_details = dict(
            zip(
                ["pymc_version", "theano_version"],
                [pymc.__version__, theano.__version__],
            )
        )

        temp_ext_met = self.external_metadata
        temp_ext_met["data"] = data_details
        temp_ext_met["exp"] = exp_details
        temp_ext_met["module"] = module_details

        return temp_ext_met

    def write_to_database(self):
        """Write out metadata to database"""
        agg_metadata = self.aggregate_metadata()
        # Convert model_kwargs to str so that they are save appropriately
        agg_metadata["model"]["model_kwargs"] = str(
            agg_metadata["model"]["model_kwargs"])
        flat_metadata = pd.json_normalize(agg_metadata)
        if not os.path.isfile(self.model_database_path):
            flat_metadata.to_csv(self.model_database_path, mode="a")
        else:
            flat_metadata.to_csv(self.model_database_path,
                                 mode="a", header=False)
        print(f"Updated model database @ {self.model_database_path}")

    def check_exists(self):
        """Check if the given fit already exists in database

        Returns:
            bool: Boolean for whether fit already exists or not
        """
        if self.fit_exists is not None:
            return self.fit_exists</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize DatabaseHandler class</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self):
    """Initialize DatabaseHandler class"""
    self.unique_cols = ["exp.model_id", "exp.save_path", "exp.fit_date"]
    self.model_database_path = MODEL_DATABASE_PATH
    self.model_save_base_dir = MODEL_SAVE_DIR

    if os.path.exists(self.model_database_path):
        self.fit_database = pd.read_csv(
            self.model_database_path, index_col=0)
        all_na = [all(x) for num, x in self.fit_database.isna().iterrows()]
        if all_na:
            print(f"{sum(all_na)} rows found with all NA, removing...")
            self.fit_database = self.fit_database.dropna(how="all")
    else:
        print("Fit database does not exist yet")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.aggregate_metadata" class="doc doc-heading">
            <code class="highlight language-python">aggregate_metadata()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Collects information regarding data and current "experiment"</p>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If 'external_metadata' has not been ingested, that needs to be done first</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary of metadata given to FitHandler class</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def aggregate_metadata(self):
    """Collects information regarding data and current "experiment"

    Raises:
        Exception: If 'external_metadata' has not been ingested, that needs to be done first

    Returns:
        dict: Dictionary of metadata given to FitHandler class
    """
    if "external_metadata" not in dir(self):
        raise Exception(
            "Fit run metdata needs to be ingested " "into data_handler first")

    data_details = dict(
        zip(
            [
                "data_dir",
                "basename",
                "animal_name",
                "session_date",
                "taste_num",
                "laser_type",
                "region_name",
            ],
            [
                self.data_dir,
                self.data_basename,
                self.animal_name,
                self.session_date,
                self.taste_num,
                self.laser_type,
                self.region_name,
            ],
        )
    )

    exp_details = dict(
        zip(
            ["exp_name", "model_id", "save_path", "fit_date"],
            [
                self.experiment_name,
                self.model_id,
                self.model_save_path,
                self.fit_date,
            ],
        )
    )

    module_details = dict(
        zip(
            ["pymc_version", "theano_version"],
            [pymc.__version__, theano.__version__],
        )
    )

    temp_ext_met = self.external_metadata
    temp_ext_met["data"] = data_details
    temp_ext_met["exp"] = exp_details
    temp_ext_met["module"] = module_details

    return temp_ext_met</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.check_exists" class="doc doc-heading">
            <code class="highlight language-python">check_exists()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if the given fit already exists in database</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>bool</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Boolean for whether fit already exists or not</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def check_exists(self):
    """Check if the given fit already exists in database

    Returns:
        bool: Boolean for whether fit already exists or not
    """
    if self.fit_exists is not None:
        return self.fit_exists</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.check_mismatched_paths" class="doc doc-heading">
            <code class="highlight language-python">check_mismatched_paths()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Check if there are any mismatched pkl files between database and directory</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pandas dataframe: Dataframe containing rows for which pkl file not present</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>list</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pkl files which cannot be matched to model in database</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>list</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>all files in save directory</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def check_mismatched_paths(self):
    """Check if there are any mismatched pkl files between database and directory

    Returns:
        pandas dataframe: Dataframe containing rows for which pkl file not present
        list: pkl files which cannot be matched to model in database
        list: all files in save directory
    """
    mismatch_from_database = [
        not os.path.exists(x + ".pkl") for x in self.fit_database["exp.save_path"]
    ]
    file_list = glob(os.path.join(self.model_save_base_dir, "*/*.pkl"))
    # Only split basename by '.' in case there are multiple '.' in filenpath
    mismatch_from_file = [
        not (
            os.path.join(
                os.path.dirname(x),
                os.path.basename(x).split(".")[0])
            in list(self.fit_database["exp.save_path"]))
        for x in file_list
    ]
    print(
        f"{sum(mismatch_from_database)} mismatches from database"
        + "\n"
        + f"{sum(mismatch_from_file)} mismatches from files"
    )
    return mismatch_from_database, mismatch_from_file, file_list</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.clear_mismatched_paths" class="doc doc-heading">
            <code class="highlight language-python">clear_mismatched_paths()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Remove mismatched files and rows in database</p>
<p>i.e. Remove
1) Files for which no entry can be found in database
2) Database entries for which no corresponding file can be found</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def clear_mismatched_paths(self):
    """Remove mismatched files and rows in database

    i.e. Remove
    1) Files for which no entry can be found in database
    2) Database entries for which no corresponding file can be found
    """
    (
        mismatch_from_database,
        mismatch_from_file,
        file_list,
    ) = self.check_mismatched_paths()
    mismatch_from_file = np.array(mismatch_from_file)
    mismatch_from_database = np.array(mismatch_from_database)
    self.fit_database = self.fit_database.loc[~mismatch_from_database]
    mismatched_files = [x for x, y in zip(
        file_list, mismatch_from_file) if y]
    for x in mismatched_files:
        os.remove(x)
    print("==== Clearing Completed ====")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.drop_duplicates" class="doc doc-heading">
            <code class="highlight language-python">drop_duplicates()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Remove duplicated rows from database</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def drop_duplicates(self):
    """Remove duplicated rows from database"""
    _, dup_inds = self.show_duplicates()
    print(f"Removing {sum(dup_inds)} duplicate rows")
    self.fit_database = self.fit_database.loc[~dup_inds]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.ingest_fit_data" class="doc doc-heading">
            <code class="highlight language-python">ingest_fit_data(met_dict)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Load external metadata</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>met_dict</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary of metadata from FitHandler class</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def ingest_fit_data(self, met_dict):
    """Load external metadata

    Args:
        met_dict (dict): Dictionary of metadata from FitHandler class
    """
    self.external_metadata = met_dict</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.set_run_params" class="doc doc-heading">
            <code class="highlight language-python">set_run_params(data_dir, experiment_name, taste_num, laser_type, region_name)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Store metadata related to inference run</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_dir</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to directory containing HDF5 file</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>experiment_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name given to fitted batch
    (for metedata). Defaults to None.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>taste_num</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Index of taste to perform fit on (Corresponds to
    INDEX of taste in spike array, not actual dig_ins)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>laser_type</code>
            </td>
            <td>
                  <code>None or <span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>None, 'on', or 'off' (For a laser session,
    which set of trials are wanted, None indicated return all trials)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>region_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Region on which to perform fit on
    (must match regions in .info file)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_run_params(self, data_dir, experiment_name, taste_num, laser_type, region_name):
    """Store metadata related to inference run

    Args:
        data_dir (str): Path to directory containing HDF5 file
        experiment_name (str): Name given to fitted batch
                (for metedata). Defaults to None.
        taste_num (int): Index of taste to perform fit on (Corresponds to
                INDEX of taste in spike array, not actual dig_ins)
        laser_type (None or str): None, 'on', or 'off' (For a laser session,
                which set of trials are wanted, None indicated return all trials)
        region_name (str): Region on which to perform fit on
                (must match regions in .info file)
    """
    self.data_dir = data_dir
    self.data_basename = os.path.basename(self.data_dir)
    self.animal_name = self.data_basename.split("_")[0]
    self.session_date = self.data_basename.split("_")[-1]

    self.experiment_name = experiment_name
    self.model_save_dir = os.path.join(
        self.model_save_base_dir, experiment_name)

    if not os.path.exists(self.model_save_dir):
        os.makedirs(self.model_save_dir)

    self.model_id = str(uuid.uuid4()).split("-")[0]
    self.model_save_path = os.path.join(
        self.model_save_dir, self.experiment_name + "_" + self.model_id
    )
    self.fit_date = date.today().strftime("%m-%d-%y")

    self.taste_num = taste_num
    self.laser_type = laser_type
    self.region_name = region_name

    self.fit_exists = None</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.show_duplicates" class="doc doc-heading">
            <code class="highlight language-python">show_duplicates(keep='first')</code>

</h3>


    <div class="doc doc-contents ">

        <p>Find duplicates in database</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>keep</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Which duplicate to keep
    (refer to pandas duplicated). Defaults to 'first'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;first&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pandas dataframe: Dataframe containing duplicated rows</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pandas series : Indices of duplicated rows</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def show_duplicates(self, keep="first"):
    """Find duplicates in database

    Args:
        keep (str, optional): Which duplicate to keep
                (refer to pandas duplicated). Defaults to 'first'.

    Returns:
        pandas dataframe: Dataframe containing duplicated rows
        pandas series : Indices of duplicated rows
    """
    dup_inds = self.fit_database.drop(
        self.unique_cols, axis=1).duplicated(keep=keep)
    return self.fit_database.loc[dup_inds], dup_inds</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.write_to_database" class="doc doc-heading">
            <code class="highlight language-python">write_to_database()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Write out metadata to database</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_to_database(self):
    """Write out metadata to database"""
    agg_metadata = self.aggregate_metadata()
    # Convert model_kwargs to str so that they are save appropriately
    agg_metadata["model"]["model_kwargs"] = str(
        agg_metadata["model"]["model_kwargs"])
    flat_metadata = pd.json_normalize(agg_metadata)
    if not os.path.isfile(self.model_database_path):
        flat_metadata.to_csv(self.model_database_path, mode="a")
    else:
        flat_metadata.to_csv(self.model_database_path,
                             mode="a", header=False)
    print(f"Updated model database @ {self.model_database_path}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.DatabaseHandler.write_updated_database" class="doc doc-heading">
            <code class="highlight language-python">write_updated_database()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Can be called following clear_mismatched_entries to update current database</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def write_updated_database(self):
    """Can be called following clear_mismatched_entries to update current database"""
    database_backup_dir = os.path.join(
        self.model_save_base_dir, ".database_backups")
    if not os.path.exists(database_backup_dir):
        os.makedirs(database_backup_dir)
    # current_date = date.today().strftime("%m-%d-%y")
    current_date = str(datetime.now()).replace(" ", "_")
    shutil.copy(
        self.model_database_path,
        os.path.join(database_backup_dir,
                     f"database_backup_{current_date}"),
    )
    self.fit_database.to_csv(self.model_database_path, mode="w")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_io.FitHandler" class="doc doc-heading">
            <code>FitHandler</code>


</h2>


    <div class="doc doc-contents ">



        <p>Class to handle pipeline of model fitting including:
1) Loading data
2) Preprocessing loaded arrays
3) Fitting model
4) Writing out fitted parameters to pkl file</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
                <pre class="highlight"><code class="language-python">class FitHandler:
    """Class to handle pipeline of model fitting including:
    1) Loading data
    2) Preprocessing loaded arrays
    3) Fitting model
    4) Writing out fitted parameters to pkl file

    """

    def __init__(
        self,
        data_dir,
        taste_num,
        region_name,
        laser_type=None,
        experiment_name=None,
        model_params_path=None,
        preprocess_params_path=None,
    ):
        """Initialize FitHandler class

        Args:
            data_dir (str): Path to directory containing HDF5 file
            taste_num (int): Index of taste to perform fit on
                    (Corresponds to INDEX of taste in spike array, not actual dig_ins)
            region_name (str): Region on which to perform fit on
                    (must match regions in .info file)
            experiment_name (str, optional): Name given to fitted batch
                    (for metedata). Defaults to None.
            model_params_path (str, optional): Path to json file
                    containing model parameters. Defaults to None.
            preprocess_params_path (str, optional): Path to json file
                    containing preprocessing parameters. Defaults to None.

        Raises:
            Exception: If "experiment_name" is None
            Exception: If "laser_type" is not in [None, 'on', 'off']
            Exception: If "taste_num" is not integer or "all"
        """

        # =============== Check for exceptions ===============
        if experiment_name is None:
            raise Exception("Please specify an experiment name")
        if laser_type not in [None, "on", "off"]:
            raise Exception('laser_type must be from [None, "on","off"]')
        if not (isinstance(taste_num, int) or taste_num == "all"):
            raise Exception('taste_num must be an integer or "all"')

        # =============== Save relevant arguments ===============
        self.data_dir = data_dir
        self.EphysData = EphysData(self.data_dir)
        # self.data = self.EphysData.get_spikes({"bla","gc","all"})

        self.taste_num = taste_num
        self.laser_type = laser_type
        self.region_name = region_name
        self.experiment_name = experiment_name

        data_handler_init_kwargs = dict(
            zip(
                [
                    "data_dir",
                    "experiment_name",
                    "taste_num",
                    "laser_type",
                    "region_name",
                ],
                [data_dir, experiment_name, taste_num, laser_type, region_name],
            )
        )
        self.database_handler = DatabaseHandler()
        self.database_handler.set_run_params(**data_handler_init_kwargs)

        if model_params_path is None:
            print("MODEL_PARAMS will have to be set")
        else:
            self.set_model_params(file_path=model_params_path)

        if preprocess_params_path is None:
            print("PREPROCESS_PARAMS will have to be set")
        else:
            self.set_preprocess_params(file_path=preprocess_params_path)

    ########################################
    # SET PARAMS
    ########################################

    def set_preprocess_params(self, time_lims, bin_width, data_transform, file_path=None):
        """Load given params as "preprocess_params" attribute

        Args:
            time_lims (array/tuple/list): Start and end of where to cut
                    spike train array
            bin_width (int): Bin width for binning spikes to counts
            data_transform (str): Indicator for which transformation to
                    use (refer to changepoint_preprocess)
            file_path (str, optional): Path to json file containing preprocess
                    parameters. Defaults to None.
        """

        if file_path is None:
            preprocess_params_dict = dict(
                zip(
                    ["time_lims", "bin_width", "data_transform"],
                    [time_lims, bin_width, data_transform],
                )
            )
            self.preprocess_params = preprocess_params_dict
            print("Set preprocess params to: {}".format(preprocess_params_dict))

        else:
            # Load json and save dict
            pass

    def set_model_params(self, states, fit, samples, model_kwargs=None, file_path=None):
        """Load given params as "model_params" attribute

        Args:
            states (int): Number of states to use in model
            fit (int): Iterations to use for model fitting (given ADVI fit)
            samples (int): Number of samples to return from fitten model
            model_kwargs (dict) : Additional paramters for model
            file_path (str, optional): Path to json file containing
                    preprocess parameters. Defaults to None.
        """

        if file_path is None:
            model_params_dict = dict(
                zip(
                    ["states", "fit", "samples", "model_kwargs"],
                    [states, fit, samples, model_kwargs],
                )
            )
            self.model_params = model_params_dict
            print("Set model params to: {}".format(model_params_dict))

        else:
            # Load json and save dict
            pass

    ########################################
    # SET PIPELINE FUNCS
    ########################################

    def set_preprocessor(self, preprocessing_func):
        """Manually set preprocessor for data e.g.

        FitHandler.set_preprocessor(
                    changepoint_preprocess.preprocess_single_taste)

        Args:
            preprocessing_func (func):
                    Function to preprocess data (refer to changepoint_preprocess)
        """
        self.preprocessor = preprocessing_func

    def preprocess_selector(self):
        """Function to return preprocess function based off of input flag

        Preprocessing can be set manually but it is preferred to
        go through preprocess selector

        Raises:
            Exception: If self.taste_num is neither int nor str

        """

        if isinstance(self.taste_num, int):
            self.set_preprocessor(
                changepoint_preprocess.preprocess_single_taste)
        elif self.taste_num == "all":
            self.set_preprocessor(changepoint_preprocess.preprocess_all_taste)
        else:
            raise Exception("Something went wrong")

    def set_model_template(self, model_template):
        """Manually set model_template for data e.g.

        FitHandler.set_model(changepoint_model.single_taste_poisson)

        Args:
            model_template (func): Function to generate model template for data]
        """
        self.model_template = model_template

    def model_template_selector(self):
        """Function to set model based off of input flag

        Models can be set manually but it is preferred to go through model selector

        Raises:
            Exception: If self.taste_num is neither int nor str

        """
        if isinstance(self.taste_num, int):
            # self.set_model_template(changepoint_model.single_taste_poisson_varsig)
            self.set_model_template(changepoint_model.single_taste_poisson)
        elif self.taste_num == "all":
            self.set_model_template(changepoint_model.all_taste_poisson)
        else:
            raise Exception("Something went wrong")

    def set_inference(self, inference_func):
        """Manually set inference function for model fit e.g.

        FitHandler.set_inference(changepoint_model.advi_fit)

        Args:
            inference_func (func): Function to use for fitting model
        """
        self.inference_func = changepoint_model.advi_fit

    def inference_func_selector(self):
        """Function to return model based off of input flag

        Currently hard-coded to use "advi_fit"
        """
        self.set_inference(changepoint_model.advi_fit)

    ########################################
    # PIPELINE FUNCS
    ########################################

    def load_spike_trains(self):
        """Helper function to load spike trains from data_dir using EphysData module"""
        full_spike_array = self.EphysData.return_region_spikes(
            region_name=self.region_name, laser=self.laser_type
        )
        if isinstance(self.taste_num, int):
            self.data = full_spike_array[self.taste_num]
        if self.taste_num == "all":
            self.data = full_spike_array
        print(
            f"Loading spike trains from {self.database_handler.data_basename}, "
            f"dig_in {self.taste_num}, laser {str(self.laser_type)}"
        )

    def preprocess_data(self):
        """Perform data preprocessing

        Will check for and complete:
        1) Raw data loaded
        2) Preprocessor selected
        """
        if "data" not in dir(self):
            self.load_spike_trains()
        if "preprocessor" not in dir(self):
            self.preprocess_selector()
        print(
            "Preprocessing spike trains, " f"preprocessing func: &lt;{self.preprocessor.__name__}&gt;")
        self.preprocessed_data = self.preprocessor(
            self.data, **self.preprocess_params)

    def create_model(self):
        """Create model and save as attribute

        Will check for and complete:
        1) Data preprocessed
        2) Model template selected
        """
        if "preprocessed_data" not in dir(self):
            self.preprocess_data()
        if "model_template" not in dir(self):
            self.model_template_selector()

        # In future iterations, before fitting model,
        # check that a similar entry doesn't exist

        print(
            f"Generating Model, model func: &lt;{self.model_template.__name__}&gt;")
        self.model = self.model_template(
            self.preprocessed_data,
            self.model_params["states"],
            **self.model_params["model_kwargs"],
        )

    def run_inference(self):
        """Perform inference on data

        Will check for and complete:
        1) Model created
        2) Inference function selected
        """
        if "model" not in dir(self):
            self.create_model()
        if "inference_func" not in dir(self):
            self.inference_func_selector()

        print(
            "Running inference, inference func: " f"&lt;{self.inference_func.__name__}&gt;")
        temp_outs = self.inference_func(
            self.model, self.model_params["fit"], self.model_params["samples"]
        )
        varnames = ["model", "approx", "lambda", "tau", "data"]
        self.inference_outs = dict(zip(varnames, temp_outs))

    def _gen_fit_metadata(self):
        """Generate metadata for fit

        Generate metadat by compiling:
        1) Preprocess parameters given as input
        2) Model parameters given as input
        3) Functions used in inference pipeline for : preprocessing,
                model generation, fitting

        Returns:
            dict: Dictionary containing compiled metadata for different
                    parts of inference pipeline
        """
        pre_params = self.preprocess_params
        model_params = self.model_params
        pre_params["preprocessor_name"] = self.preprocessor.__name__
        model_params["model_template_name"] = self.model_template.__name__
        model_params["inference_func_name"] = self.inference_func.__name__
        fin_dict = dict(zip(["preprocess", "model"],
                        [pre_params, model_params]))
        return fin_dict

    def _pass_metadata_to_handler(self):
        """Function to coordinate transfer of metadata to DatabaseHandler"""
        self.database_handler.ingest_fit_data(self._gen_fit_metadata())

    def _return_fit_output(self):
        """Compile data, model, fit, and metadata to save output

        Returns:
            dict: Dictionary containing fitted model data and metadata
        """
        self._pass_metadata_to_handler()
        agg_metadata = self.database_handler.aggregate_metadata()
        return {"model_data": self.inference_outs, "metadata": agg_metadata}

    def save_fit_output(self):
        """Save fit output (fitted data + metadata) to pkl file"""
        if "inference_outs" not in dir(self):
            self.run_inference()
        out_dict = self._return_fit_output()

        # Save output to pkl file
        with open(self.database_handler.model_save_path + ".pkl", "wb") as buff:
            pickle.dump(out_dict, buff)
        print(
            f"Saved full output to {self.database_handler.model_save_path}.pkl")

        # # Create a copy without the model to avoid pickling issues with PyMC5
        # picklable_dict = out_dict.copy()
        # if "model_data" in picklable_dict and "model" in picklable_dict["model_data"]:
        #     picklable_model_data = picklable_dict["model_data"].copy()
        #     # Remove the model object as it contains unpicklable local functions in PyMC5
        #     picklable_model_data.pop("model", None)
        #     picklable_dict["model_data"] = picklable_model_data
        #
        # with open(self.database_handler.model_save_path + ".pkl", "wb") as buff:
        #     try:
        #         pickle.dump(picklable_dict, buff)
        #     except (TypeError, AttributeError) as e:
        #         print(
        #             f"Warning: Full pickling failed ({e}). Saving metadata-only version.")
        #         # If pickling fails, save only metadata and basic info
        #         model_data_fallback = {
        #             "tau_array": picklable_dict.get("model_data", {}).get("tau_array"),
        #             "processed_spikes": picklable_dict.get("model_data", {}).get("processed_spikes"),
        #         }
        #
        #         # Try to save approx.hist for ELBO plotting if available
        #         approx_obj = picklable_dict.get("model_data", {}).get("approx")
        #         if approx_obj and hasattr(approx_obj, 'hist'):
        #             try:
        #                 # Create a simple object with just the hist attribute
        #                 model_data_fallback["approx"] = SimpleApprox(
        #                     approx_obj.hist)
        #             except Exception:
        #                 # If even hist fails to pickle, skip it
        #                 pass
        #
        #         metadata_only_dict = {
        #             "metadata": picklable_dict.get("metadata", {}),
        #             "model_data": model_data_fallback
        #         }
        #         pickle.dump(metadata_only_dict, buff)

        json_file_name = os.path.join(
            self.database_handler.model_save_path + ".info")
        with open(json_file_name, "w") as file:
            json.dump(out_dict["metadata"], file, indent=4)

        self.database_handler.write_to_database()

        print(
            "Saving inference output to : \n"
            f"{self.database_handler.model_save_dir}"
            "\n" + "================================" + "\n"
        )</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_dir, taste_num, region_name, laser_type=None, experiment_name=None, model_params_path=None, preprocess_params_path=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize FitHandler class</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_dir</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to directory containing HDF5 file</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>taste_num</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Index of taste to perform fit on
    (Corresponds to INDEX of taste in spike array, not actual dig_ins)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>region_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Region on which to perform fit on
    (must match regions in .info file)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>experiment_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name given to fitted batch
    (for metedata). Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>model_params_path</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to json file
    containing model parameters. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>preprocess_params_path</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to json file
    containing preprocessing parameters. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If "experiment_name" is None</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If "laser_type" is not in [None, 'on', 'off']</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If "taste_num" is not integer or "all"</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(
    self,
    data_dir,
    taste_num,
    region_name,
    laser_type=None,
    experiment_name=None,
    model_params_path=None,
    preprocess_params_path=None,
):
    """Initialize FitHandler class

    Args:
        data_dir (str): Path to directory containing HDF5 file
        taste_num (int): Index of taste to perform fit on
                (Corresponds to INDEX of taste in spike array, not actual dig_ins)
        region_name (str): Region on which to perform fit on
                (must match regions in .info file)
        experiment_name (str, optional): Name given to fitted batch
                (for metedata). Defaults to None.
        model_params_path (str, optional): Path to json file
                containing model parameters. Defaults to None.
        preprocess_params_path (str, optional): Path to json file
                containing preprocessing parameters. Defaults to None.

    Raises:
        Exception: If "experiment_name" is None
        Exception: If "laser_type" is not in [None, 'on', 'off']
        Exception: If "taste_num" is not integer or "all"
    """

    # =============== Check for exceptions ===============
    if experiment_name is None:
        raise Exception("Please specify an experiment name")
    if laser_type not in [None, "on", "off"]:
        raise Exception('laser_type must be from [None, "on","off"]')
    if not (isinstance(taste_num, int) or taste_num == "all"):
        raise Exception('taste_num must be an integer or "all"')

    # =============== Save relevant arguments ===============
    self.data_dir = data_dir
    self.EphysData = EphysData(self.data_dir)
    # self.data = self.EphysData.get_spikes({"bla","gc","all"})

    self.taste_num = taste_num
    self.laser_type = laser_type
    self.region_name = region_name
    self.experiment_name = experiment_name

    data_handler_init_kwargs = dict(
        zip(
            [
                "data_dir",
                "experiment_name",
                "taste_num",
                "laser_type",
                "region_name",
            ],
            [data_dir, experiment_name, taste_num, laser_type, region_name],
        )
    )
    self.database_handler = DatabaseHandler()
    self.database_handler.set_run_params(**data_handler_init_kwargs)

    if model_params_path is None:
        print("MODEL_PARAMS will have to be set")
    else:
        self.set_model_params(file_path=model_params_path)

    if preprocess_params_path is None:
        print("PREPROCESS_PARAMS will have to be set")
    else:
        self.set_preprocess_params(file_path=preprocess_params_path)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.create_model" class="doc doc-heading">
            <code class="highlight language-python">create_model()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Create model and save as attribute</p>
<p>Will check for and complete:
1) Data preprocessed
2) Model template selected</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def create_model(self):
    """Create model and save as attribute

    Will check for and complete:
    1) Data preprocessed
    2) Model template selected
    """
    if "preprocessed_data" not in dir(self):
        self.preprocess_data()
    if "model_template" not in dir(self):
        self.model_template_selector()

    # In future iterations, before fitting model,
    # check that a similar entry doesn't exist

    print(
        f"Generating Model, model func: &lt;{self.model_template.__name__}&gt;")
    self.model = self.model_template(
        self.preprocessed_data,
        self.model_params["states"],
        **self.model_params["model_kwargs"],
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.inference_func_selector" class="doc doc-heading">
            <code class="highlight language-python">inference_func_selector()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Function to return model based off of input flag</p>
<p>Currently hard-coded to use "advi_fit"</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def inference_func_selector(self):
    """Function to return model based off of input flag

    Currently hard-coded to use "advi_fit"
    """
    self.set_inference(changepoint_model.advi_fit)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.load_spike_trains" class="doc doc-heading">
            <code class="highlight language-python">load_spike_trains()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Helper function to load spike trains from data_dir using EphysData module</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def load_spike_trains(self):
    """Helper function to load spike trains from data_dir using EphysData module"""
    full_spike_array = self.EphysData.return_region_spikes(
        region_name=self.region_name, laser=self.laser_type
    )
    if isinstance(self.taste_num, int):
        self.data = full_spike_array[self.taste_num]
    if self.taste_num == "all":
        self.data = full_spike_array
    print(
        f"Loading spike trains from {self.database_handler.data_basename}, "
        f"dig_in {self.taste_num}, laser {str(self.laser_type)}"
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.model_template_selector" class="doc doc-heading">
            <code class="highlight language-python">model_template_selector()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Function to set model based off of input flag</p>
<p>Models can be set manually but it is preferred to go through model selector</p>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If self.taste_num is neither int nor str</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def model_template_selector(self):
    """Function to set model based off of input flag

    Models can be set manually but it is preferred to go through model selector

    Raises:
        Exception: If self.taste_num is neither int nor str

    """
    if isinstance(self.taste_num, int):
        # self.set_model_template(changepoint_model.single_taste_poisson_varsig)
        self.set_model_template(changepoint_model.single_taste_poisson)
    elif self.taste_num == "all":
        self.set_model_template(changepoint_model.all_taste_poisson)
    else:
        raise Exception("Something went wrong")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.preprocess_data" class="doc doc-heading">
            <code class="highlight language-python">preprocess_data()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Perform data preprocessing</p>
<p>Will check for and complete:
1) Raw data loaded
2) Preprocessor selected</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def preprocess_data(self):
    """Perform data preprocessing

    Will check for and complete:
    1) Raw data loaded
    2) Preprocessor selected
    """
    if "data" not in dir(self):
        self.load_spike_trains()
    if "preprocessor" not in dir(self):
        self.preprocess_selector()
    print(
        "Preprocessing spike trains, " f"preprocessing func: &lt;{self.preprocessor.__name__}&gt;")
    self.preprocessed_data = self.preprocessor(
        self.data, **self.preprocess_params)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.preprocess_selector" class="doc doc-heading">
            <code class="highlight language-python">preprocess_selector()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Function to return preprocess function based off of input flag</p>
<p>Preprocessing can be set manually but it is preferred to
go through preprocess selector</p>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If self.taste_num is neither int nor str</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def preprocess_selector(self):
    """Function to return preprocess function based off of input flag

    Preprocessing can be set manually but it is preferred to
    go through preprocess selector

    Raises:
        Exception: If self.taste_num is neither int nor str

    """

    if isinstance(self.taste_num, int):
        self.set_preprocessor(
            changepoint_preprocess.preprocess_single_taste)
    elif self.taste_num == "all":
        self.set_preprocessor(changepoint_preprocess.preprocess_all_taste)
    else:
        raise Exception("Something went wrong")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.run_inference" class="doc doc-heading">
            <code class="highlight language-python">run_inference()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Perform inference on data</p>
<p>Will check for and complete:
1) Model created
2) Inference function selected</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def run_inference(self):
    """Perform inference on data

    Will check for and complete:
    1) Model created
    2) Inference function selected
    """
    if "model" not in dir(self):
        self.create_model()
    if "inference_func" not in dir(self):
        self.inference_func_selector()

    print(
        "Running inference, inference func: " f"&lt;{self.inference_func.__name__}&gt;")
    temp_outs = self.inference_func(
        self.model, self.model_params["fit"], self.model_params["samples"]
    )
    varnames = ["model", "approx", "lambda", "tau", "data"]
    self.inference_outs = dict(zip(varnames, temp_outs))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.save_fit_output" class="doc doc-heading">
            <code class="highlight language-python">save_fit_output()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Save fit output (fitted data + metadata) to pkl file</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def save_fit_output(self):
    """Save fit output (fitted data + metadata) to pkl file"""
    if "inference_outs" not in dir(self):
        self.run_inference()
    out_dict = self._return_fit_output()

    # Save output to pkl file
    with open(self.database_handler.model_save_path + ".pkl", "wb") as buff:
        pickle.dump(out_dict, buff)
    print(
        f"Saved full output to {self.database_handler.model_save_path}.pkl")

    # # Create a copy without the model to avoid pickling issues with PyMC5
    # picklable_dict = out_dict.copy()
    # if "model_data" in picklable_dict and "model" in picklable_dict["model_data"]:
    #     picklable_model_data = picklable_dict["model_data"].copy()
    #     # Remove the model object as it contains unpicklable local functions in PyMC5
    #     picklable_model_data.pop("model", None)
    #     picklable_dict["model_data"] = picklable_model_data
    #
    # with open(self.database_handler.model_save_path + ".pkl", "wb") as buff:
    #     try:
    #         pickle.dump(picklable_dict, buff)
    #     except (TypeError, AttributeError) as e:
    #         print(
    #             f"Warning: Full pickling failed ({e}). Saving metadata-only version.")
    #         # If pickling fails, save only metadata and basic info
    #         model_data_fallback = {
    #             "tau_array": picklable_dict.get("model_data", {}).get("tau_array"),
    #             "processed_spikes": picklable_dict.get("model_data", {}).get("processed_spikes"),
    #         }
    #
    #         # Try to save approx.hist for ELBO plotting if available
    #         approx_obj = picklable_dict.get("model_data", {}).get("approx")
    #         if approx_obj and hasattr(approx_obj, 'hist'):
    #             try:
    #                 # Create a simple object with just the hist attribute
    #                 model_data_fallback["approx"] = SimpleApprox(
    #                     approx_obj.hist)
    #             except Exception:
    #                 # If even hist fails to pickle, skip it
    #                 pass
    #
    #         metadata_only_dict = {
    #             "metadata": picklable_dict.get("metadata", {}),
    #             "model_data": model_data_fallback
    #         }
    #         pickle.dump(metadata_only_dict, buff)

    json_file_name = os.path.join(
        self.database_handler.model_save_path + ".info")
    with open(json_file_name, "w") as file:
        json.dump(out_dict["metadata"], file, indent=4)

    self.database_handler.write_to_database()

    print(
        "Saving inference output to : \n"
        f"{self.database_handler.model_save_dir}"
        "\n" + "================================" + "\n"
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.set_inference" class="doc doc-heading">
            <code class="highlight language-python">set_inference(inference_func)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Manually set inference function for model fit e.g.</p>
<p>FitHandler.set_inference(changepoint_model.advi_fit)</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>inference_func</code>
            </td>
            <td>
                  <code><span title="func">func</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Function to use for fitting model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_inference(self, inference_func):
    """Manually set inference function for model fit e.g.

    FitHandler.set_inference(changepoint_model.advi_fit)

    Args:
        inference_func (func): Function to use for fitting model
    """
    self.inference_func = changepoint_model.advi_fit</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.set_model_params" class="doc doc-heading">
            <code class="highlight language-python">set_model_params(states, fit, samples, model_kwargs=None, file_path=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Load given params as "model_params" attribute</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to use in model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>fit</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Iterations to use for model fitting (given ADVI fit)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>samples</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of samples to return from fitten model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>model_kwargs (dict) </code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional paramters for model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>file_path</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to json file containing
    preprocess parameters. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_model_params(self, states, fit, samples, model_kwargs=None, file_path=None):
    """Load given params as "model_params" attribute

    Args:
        states (int): Number of states to use in model
        fit (int): Iterations to use for model fitting (given ADVI fit)
        samples (int): Number of samples to return from fitten model
        model_kwargs (dict) : Additional paramters for model
        file_path (str, optional): Path to json file containing
                preprocess parameters. Defaults to None.
    """

    if file_path is None:
        model_params_dict = dict(
            zip(
                ["states", "fit", "samples", "model_kwargs"],
                [states, fit, samples, model_kwargs],
            )
        )
        self.model_params = model_params_dict
        print("Set model params to: {}".format(model_params_dict))

    else:
        # Load json and save dict
        pass</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.set_model_template" class="doc doc-heading">
            <code class="highlight language-python">set_model_template(model_template)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Manually set model_template for data e.g.</p>
<p>FitHandler.set_model(changepoint_model.single_taste_poisson)</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>model_template</code>
            </td>
            <td>
                  <code><span title="func">func</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Function to generate model template for data]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_model_template(self, model_template):
    """Manually set model_template for data e.g.

    FitHandler.set_model(changepoint_model.single_taste_poisson)

    Args:
        model_template (func): Function to generate model template for data]
    """
    self.model_template = model_template</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.set_preprocess_params" class="doc doc-heading">
            <code class="highlight language-python">set_preprocess_params(time_lims, bin_width, data_transform, file_path=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Load given params as "preprocess_params" attribute</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>time_lims</code>
            </td>
            <td>
                  <code><span title="array">array</span> / <span title="tuple">tuple</span> / <span title="list">list</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Start and end of where to cut
    spike train array</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bin_width</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Bin width for binning spikes to counts</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>data_transform</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indicator for which transformation to
    use (refer to changepoint_preprocess)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>file_path</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Path to json file containing preprocess
    parameters. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_preprocess_params(self, time_lims, bin_width, data_transform, file_path=None):
    """Load given params as "preprocess_params" attribute

    Args:
        time_lims (array/tuple/list): Start and end of where to cut
                spike train array
        bin_width (int): Bin width for binning spikes to counts
        data_transform (str): Indicator for which transformation to
                use (refer to changepoint_preprocess)
        file_path (str, optional): Path to json file containing preprocess
                parameters. Defaults to None.
    """

    if file_path is None:
        preprocess_params_dict = dict(
            zip(
                ["time_lims", "bin_width", "data_transform"],
                [time_lims, bin_width, data_transform],
            )
        )
        self.preprocess_params = preprocess_params_dict
        print("Set preprocess params to: {}".format(preprocess_params_dict))

    else:
        # Load json and save dict
        pass</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_io.FitHandler.set_preprocessor" class="doc doc-heading">
            <code class="highlight language-python">set_preprocessor(preprocessing_func)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Manually set preprocessor for data e.g.</p>
<p>FitHandler.set_preprocessor(
            changepoint_preprocess.preprocess_single_taste)</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>preprocessing_func</code>
            </td>
            <td>
                  <code><span title="func">func</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <pre><code>Function to preprocess data (refer to changepoint_preprocess)
</code></pre>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_preprocessor(self, preprocessing_func):
    """Manually set preprocessor for data e.g.

    FitHandler.set_preprocessor(
                changepoint_preprocess.preprocess_single_taste)

    Args:
        preprocessing_func (func):
                Function to preprocess data (refer to changepoint_preprocess)
    """
    self.preprocessor = preprocessing_func</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_io.SimpleApprox" class="doc doc-heading">
            <code>SimpleApprox</code>


</h2>


    <div class="doc doc-contents ">



        <p>Simple approximation object that only stores the hist attribute for ELBO plotting</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_io.py</code></summary>
                <pre class="highlight"><code class="language-python">class SimpleApprox:
    """Simple approximation object that only stores the hist attribute for ELBO plotting"""

    def __init__(self, hist):
        self.hist = hist</code></pre>
              </details>



  <div class="doc doc-children">












  </div>

    </div>

</div>




  </div>

    </div>

</div><h2 id="model-building-functions"><strong>=== Model building functions ===</strong></h2>


<div class="doc doc-object doc-module">



<a id="pytau.changepoint_model"></a>
    <div class="doc doc-contents first">

        <p>pymc Blackbox Variational Inference implementation
of Poisson Likelihood Changepoint for spike trains.</p>










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.AllTastePoisson" class="doc doc-heading">
            <code>AllTastePoisson</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>** Model to fit changepoint to all tastes **
** Largely taken from "_v1/poisson_all_tastes_changepoint_model.py"</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class AllTastePoisson(ChangepointModel):
    """
    ** Model to fit changepoint to all tastes **
    ** Largely taken from "_v1/poisson_all_tastes_changepoint_model.py"
    """

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (4D Numpy array): tastes, trials, neurons, time_bins
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states

        # Unroll arrays along taste axis
        data_array_long = np.concatenate(data_array, axis=0)

        # Find mean firing for initial values
        tastes = data_array.shape[0]
        length = data_array.shape[-1]
        nrns = data_array.shape[2]
        trials = data_array.shape[1]

        split_list = np.array_split(data_array, n_states, axis=-1)
        # Cut all to the same size
        min_val = min([x.shape[-1] for x in split_list])
        split_array = np.array([x[..., :min_val] for x in split_list])
        mean_vals = np.mean(split_array, axis=(2, -1)).swapaxes(0, 1)
        mean_vals += 0.01  # To avoid zero starting prob
        mean_nrn_vals = np.mean(mean_vals, axis=(0, 1))

        # Find evenly spaces switchpoints for initial values
        idx = np.arange(data_array.shape[-1])  # Index
        array_idx = np.broadcast_to(idx, data_array_long.shape)
        even_switches = np.linspace(0, idx.max(), n_states + 1)
        even_switches_normal = even_switches / np.max(even_switches)

        taste_label = np.repeat(
            np.arange(data_array.shape[0]), data_array.shape[1])
        trial_num = array_idx.shape[0]

        # Being constructing model
        with pm.Model() as model:
            # Hierarchical firing rates
            # Refer to model diagram
            # Mean firing rate of neuron AT ALL TIMES
            lambda_nrn = pm.Exponential(
                "lambda_nrn", 1 / mean_nrn_vals, shape=(mean_vals.shape[-1])
            )
            # Priors for each state, derived from each neuron
            # Mean firing rate of neuron IN EACH STATE (averaged across tastes)
            lambda_state = pm.Exponential(
                "lambda_state", lambda_nrn, shape=(mean_vals.shape[1:]))
            # Mean firing rate of neuron PER STATE PER TASTE
            lambda_latent = pm.Exponential(
                "lambda",
                lambda_state[np.newaxis, :, :],
                initval=mean_vals,
                shape=(mean_vals.shape),
            )

            # Changepoint time variable
            # INDEPENDENT TAU FOR EVERY TRIAL
            a = pm.HalfNormal("a_tau", 3.0, shape=n_states - 1)
            b = pm.HalfNormal("b_tau", 3.0, shape=n_states - 1)

            # Stack produces n_states x trials --&gt; That gets transposed
            # to trials x n_states and gets sorted along n_states (axis=-1)
            # Sort should work the same way as the Ordered transform --&gt;
            # see rv_sort_test.ipynb
            tau_latent = pm.Beta(
                "tau_latent",
                a,
                b,
                shape=(trial_num, n_states - 1),
                initval=tt.tile(even_switches_normal[1:(
                    n_states)], (array_idx.shape[0], 1)),
            ).sort(axis=-1)

            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((tastes * trials, 1, length)), weight_stack], axis=1
            )
            inverse_stack = 1 - weight_stack[:, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((tastes * trials, 1, length))], axis=1
            )
            weight_stack = weight_stack * inverse_stack
            weight_stack = tt.tile(
                weight_stack[:, :, None, :], (1, 1, nrns, 1))

            lambda_latent = lambda_latent.dimshuffle(2, 0, 1)
            lambda_latent = tt.repeat(lambda_latent, trials, axis=1)
            lambda_latent = tt.tile(
                lambda_latent[..., None], (1, 1, 1, length))
            lambda_latent = lambda_latent.dimshuffle(1, 2, 0, 3)
            lambda_ = tt.sum(lambda_latent * weight_stack, axis=1)

            observation = pm.Poisson("obs", lambda_, observed=data_array_long)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (2, 5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = AllTastePoisson(test_data, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "lambda_nrn" in trace.varnames
        assert "lambda_state" in trace.varnames

        print("Test for AllTastePoisson passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoisson.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>4D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tastes, trials, neurons, time_bins</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (4D Numpy array): tastes, trials, neurons, time_bins
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoisson.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states

    # Unroll arrays along taste axis
    data_array_long = np.concatenate(data_array, axis=0)

    # Find mean firing for initial values
    tastes = data_array.shape[0]
    length = data_array.shape[-1]
    nrns = data_array.shape[2]
    trials = data_array.shape[1]

    split_list = np.array_split(data_array, n_states, axis=-1)
    # Cut all to the same size
    min_val = min([x.shape[-1] for x in split_list])
    split_array = np.array([x[..., :min_val] for x in split_list])
    mean_vals = np.mean(split_array, axis=(2, -1)).swapaxes(0, 1)
    mean_vals += 0.01  # To avoid zero starting prob
    mean_nrn_vals = np.mean(mean_vals, axis=(0, 1))

    # Find evenly spaces switchpoints for initial values
    idx = np.arange(data_array.shape[-1])  # Index
    array_idx = np.broadcast_to(idx, data_array_long.shape)
    even_switches = np.linspace(0, idx.max(), n_states + 1)
    even_switches_normal = even_switches / np.max(even_switches)

    taste_label = np.repeat(
        np.arange(data_array.shape[0]), data_array.shape[1])
    trial_num = array_idx.shape[0]

    # Being constructing model
    with pm.Model() as model:
        # Hierarchical firing rates
        # Refer to model diagram
        # Mean firing rate of neuron AT ALL TIMES
        lambda_nrn = pm.Exponential(
            "lambda_nrn", 1 / mean_nrn_vals, shape=(mean_vals.shape[-1])
        )
        # Priors for each state, derived from each neuron
        # Mean firing rate of neuron IN EACH STATE (averaged across tastes)
        lambda_state = pm.Exponential(
            "lambda_state", lambda_nrn, shape=(mean_vals.shape[1:]))
        # Mean firing rate of neuron PER STATE PER TASTE
        lambda_latent = pm.Exponential(
            "lambda",
            lambda_state[np.newaxis, :, :],
            initval=mean_vals,
            shape=(mean_vals.shape),
        )

        # Changepoint time variable
        # INDEPENDENT TAU FOR EVERY TRIAL
        a = pm.HalfNormal("a_tau", 3.0, shape=n_states - 1)
        b = pm.HalfNormal("b_tau", 3.0, shape=n_states - 1)

        # Stack produces n_states x trials --&gt; That gets transposed
        # to trials x n_states and gets sorted along n_states (axis=-1)
        # Sort should work the same way as the Ordered transform --&gt;
        # see rv_sort_test.ipynb
        tau_latent = pm.Beta(
            "tau_latent",
            a,
            b,
            shape=(trial_num, n_states - 1),
            initval=tt.tile(even_switches_normal[1:(
                n_states)], (array_idx.shape[0], 1)),
        ).sort(axis=-1)

        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, :, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((tastes * trials, 1, length)), weight_stack], axis=1
        )
        inverse_stack = 1 - weight_stack[:, 1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((tastes * trials, 1, length))], axis=1
        )
        weight_stack = weight_stack * inverse_stack
        weight_stack = tt.tile(
            weight_stack[:, :, None, :], (1, 1, nrns, 1))

        lambda_latent = lambda_latent.dimshuffle(2, 0, 1)
        lambda_latent = tt.repeat(lambda_latent, trials, axis=1)
        lambda_latent = tt.tile(
            lambda_latent[..., None], (1, 1, 1, length))
        lambda_latent = lambda_latent.dimshuffle(1, 2, 0, 3)
        lambda_ = tt.sum(lambda_latent * weight_stack, axis=1)

        observation = pm.Poisson("obs", lambda_, observed=data_array_long)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoisson.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (2, 5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = AllTastePoisson(test_data, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "lambda_nrn" in trace.varnames
    assert "lambda_state" in trace.varnames

    print("Test for AllTastePoisson passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.AllTastePoissonTrialSwitch" class="doc doc-heading">
            <code>AllTastePoissonTrialSwitch</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Assuming only emissions change across trials
Changepoint distribution remains constant</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class AllTastePoissonTrialSwitch(ChangepointModel):
    """
    Assuming only emissions change across trials
    Changepoint distribution remains constant
    """

    def __init__(self, data_array, switch_components, n_states, **kwargs):
        """
        Args:
            data_array (4D Numpy array): tastes, trials, neurons, time_bins
            switch_components (int): Number of trial switch components
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.switch_components = switch_components
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        switch_components = self.switch_components
        n_states = self.n_states

        tastes, trial_num, nrn_num, time_bins = data_array.shape

        with pm.Model() as model:
            # Define Emissions
            # =================================================

            # nrns
            nrn_lambda = pm.Exponential("nrn_lambda", 10, shape=(nrn_num))

            # tastes x nrns
            taste_lambda = pm.Exponential(
                "taste_lambda", nrn_lambda.dimshuffle("x", 0), shape=(tastes, nrn_num)
            )

            # tastes x nrns x switch_comps
            trial_lambda = pm.Exponential(
                "trial_lambda",
                taste_lambda.dimshuffle(0, 1, "x"),
                shape=(tastes, nrn_num, switch_components),
            )

            # tastes x nrns x switch_comps x n_states
            state_lambda = pm.Exponential(
                "state_lambda",
                trial_lambda.dimshuffle(0, 1, 2, "x"),
                shape=(tastes, nrn_num, switch_components, n_states),
            )

            # Define Changepoints
            # =================================================
            # Assuming distribution of changepoints remains
            # the same across all trials

            a = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

            even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
            tau_latent = pm.Beta(
                "tau_latent",
                a,
                b,
                # initval=even_switches,
                shape=(tastes, trial_num, n_states - 1),
            ).sort(axis=-1)

            # Tasets x Trials x Changepoints
            tau = pm.Deterministic("tau", time_bins * tau_latent)

            # Define trial switches
            # Will have same structure as regular changepoints

            # a_trial = pm.HalfCauchy('a_trial', 3., shape = switch_components - 1)
            # b_trial = pm.HalfCauchy('b_trial', 3., shape = switch_components - 1)

            even_trial_switches = np.linspace(
                0, 1, switch_components + 1)[1:-1]
            tau_trial_latent = pm.Beta(
                "tau_trial_latent",
                1,
                1,
                initval=even_trial_switches,
                shape=(switch_components - 1),
            ).sort(axis=-1)

            # Trial_changepoints
            # =================================================
            tau_trial = pm.Deterministic(
                "tau_trial", trial_num * tau_trial_latent)

            trial_idx = np.arange(trial_num)
            trial_selector = tt.math.sigmoid(
                trial_idx[np.newaxis, :] - tau_trial.dimshuffle(0, "x")
            )

            trial_selector = tt.concatenate(
                [np.ones((1, trial_num)), trial_selector], axis=0)
            inverse_trial_selector = 1 - trial_selector[1:, :]
            inverse_trial_selector = tt.concatenate(
                [inverse_trial_selector, np.ones((1, trial_num))], axis=0
            )

            # switch_comps x trials
            trial_selector = np.multiply(
                trial_selector, inverse_trial_selector)

            # state_lambda: tastes x nrns x switch_comps x states

            # selected_trial_lambda : tastes x nrns x states x trials
            selected_trial_lambda = pm.Deterministic(
                "selected_trial_lambda",
                tt.sum(
                    # "tastes" x "nrns" x switch_comps x "states" x trials
                    trial_selector.dimshuffle("x", "x", 0, "x", 1)
                    * state_lambda.dimshuffle(0, 1, 2, 3, "x"),
                    axis=2,
                ),
            )

            # First, we can "select" sets of emissions depending on trial_changepoints
            # =================================================
            trial_idx = np.arange(trial_num)
            trial_selector = tt.math.sigmoid(
                trial_idx[np.newaxis, :] - tau_trial.dimshuffle(0, "x")
            )

            trial_selector = tt.concatenate(
                [np.ones((1, trial_num)), trial_selector], axis=0)
            inverse_trial_selector = 1 - trial_selector[1:, :]
            inverse_trial_selector = tt.concatenate(
                [inverse_trial_selector, np.ones((1, trial_num))], axis=0
            )

            # switch_comps x trials
            trial_selector = np.multiply(
                trial_selector, inverse_trial_selector)

            # Then, we can select state_emissions for every trial
            # =================================================

            idx = np.arange(time_bins)

            # tau : Tastes x Trials x Changepoints
            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, :, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((tastes, trial_num, 1, time_bins)), weight_stack], axis=2
            )
            inverse_stack = 1 - weight_stack[:, :, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((tastes, trial_num, 1, time_bins))], axis=2
            )

            # Tastes x Trials x states x Time
            weight_stack = np.multiply(weight_stack, inverse_stack)

            # Putting everything together
            # =================================================

            # selected_trial_lambda :           tastes x nrns x states x trials
            # Convert selected_trial_lambda --&gt; tastes x trials x nrns x states x "time"

            # weight_stack :           tastes x trials x states x time
            # Convert weight_stack --&gt; tastes x trials x "nrns" x states x time

            # tastes x trials x nrns x time
            lambda_ = tt.sum(
                selected_trial_lambda.dimshuffle(0, 3, 1, 2, "x")
                * weight_stack.dimshuffle(0, 1, "x", 2, 3),
                axis=3,
            )

            # Add observations
            observation = pm.Poisson("obs", lambda_, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (2, 5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = AllTastePoissonTrialSwitch(
            test_data, self.switch_components, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "nrn_lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "tau_trial" in trace.varnames
        assert "state_lambda" in trace.varnames
        assert "taste_lambda" in trace.varnames

        print("Test for AllTastePoissonTrialSwitch passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoissonTrialSwitch.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, switch_components, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>4D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tastes, trials, neurons, time_bins</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>switch_components</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of trial switch components</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, switch_components, n_states, **kwargs):
    """
    Args:
        data_array (4D Numpy array): tastes, trials, neurons, time_bins
        switch_components (int): Number of trial switch components
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.switch_components = switch_components
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoissonTrialSwitch.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    switch_components = self.switch_components
    n_states = self.n_states

    tastes, trial_num, nrn_num, time_bins = data_array.shape

    with pm.Model() as model:
        # Define Emissions
        # =================================================

        # nrns
        nrn_lambda = pm.Exponential("nrn_lambda", 10, shape=(nrn_num))

        # tastes x nrns
        taste_lambda = pm.Exponential(
            "taste_lambda", nrn_lambda.dimshuffle("x", 0), shape=(tastes, nrn_num)
        )

        # tastes x nrns x switch_comps
        trial_lambda = pm.Exponential(
            "trial_lambda",
            taste_lambda.dimshuffle(0, 1, "x"),
            shape=(tastes, nrn_num, switch_components),
        )

        # tastes x nrns x switch_comps x n_states
        state_lambda = pm.Exponential(
            "state_lambda",
            trial_lambda.dimshuffle(0, 1, 2, "x"),
            shape=(tastes, nrn_num, switch_components, n_states),
        )

        # Define Changepoints
        # =================================================
        # Assuming distribution of changepoints remains
        # the same across all trials

        a = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
        b = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
        tau_latent = pm.Beta(
            "tau_latent",
            a,
            b,
            # initval=even_switches,
            shape=(tastes, trial_num, n_states - 1),
        ).sort(axis=-1)

        # Tasets x Trials x Changepoints
        tau = pm.Deterministic("tau", time_bins * tau_latent)

        # Define trial switches
        # Will have same structure as regular changepoints

        # a_trial = pm.HalfCauchy('a_trial', 3., shape = switch_components - 1)
        # b_trial = pm.HalfCauchy('b_trial', 3., shape = switch_components - 1)

        even_trial_switches = np.linspace(
            0, 1, switch_components + 1)[1:-1]
        tau_trial_latent = pm.Beta(
            "tau_trial_latent",
            1,
            1,
            initval=even_trial_switches,
            shape=(switch_components - 1),
        ).sort(axis=-1)

        # Trial_changepoints
        # =================================================
        tau_trial = pm.Deterministic(
            "tau_trial", trial_num * tau_trial_latent)

        trial_idx = np.arange(trial_num)
        trial_selector = tt.math.sigmoid(
            trial_idx[np.newaxis, :] - tau_trial.dimshuffle(0, "x")
        )

        trial_selector = tt.concatenate(
            [np.ones((1, trial_num)), trial_selector], axis=0)
        inverse_trial_selector = 1 - trial_selector[1:, :]
        inverse_trial_selector = tt.concatenate(
            [inverse_trial_selector, np.ones((1, trial_num))], axis=0
        )

        # switch_comps x trials
        trial_selector = np.multiply(
            trial_selector, inverse_trial_selector)

        # state_lambda: tastes x nrns x switch_comps x states

        # selected_trial_lambda : tastes x nrns x states x trials
        selected_trial_lambda = pm.Deterministic(
            "selected_trial_lambda",
            tt.sum(
                # "tastes" x "nrns" x switch_comps x "states" x trials
                trial_selector.dimshuffle("x", "x", 0, "x", 1)
                * state_lambda.dimshuffle(0, 1, 2, 3, "x"),
                axis=2,
            ),
        )

        # First, we can "select" sets of emissions depending on trial_changepoints
        # =================================================
        trial_idx = np.arange(trial_num)
        trial_selector = tt.math.sigmoid(
            trial_idx[np.newaxis, :] - tau_trial.dimshuffle(0, "x")
        )

        trial_selector = tt.concatenate(
            [np.ones((1, trial_num)), trial_selector], axis=0)
        inverse_trial_selector = 1 - trial_selector[1:, :]
        inverse_trial_selector = tt.concatenate(
            [inverse_trial_selector, np.ones((1, trial_num))], axis=0
        )

        # switch_comps x trials
        trial_selector = np.multiply(
            trial_selector, inverse_trial_selector)

        # Then, we can select state_emissions for every trial
        # =================================================

        idx = np.arange(time_bins)

        # tau : Tastes x Trials x Changepoints
        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, :, :, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((tastes, trial_num, 1, time_bins)), weight_stack], axis=2
        )
        inverse_stack = 1 - weight_stack[:, :, 1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((tastes, trial_num, 1, time_bins))], axis=2
        )

        # Tastes x Trials x states x Time
        weight_stack = np.multiply(weight_stack, inverse_stack)

        # Putting everything together
        # =================================================

        # selected_trial_lambda :           tastes x nrns x states x trials
        # Convert selected_trial_lambda --&gt; tastes x trials x nrns x states x "time"

        # weight_stack :           tastes x trials x states x time
        # Convert weight_stack --&gt; tastes x trials x "nrns" x states x time

        # tastes x trials x nrns x time
        lambda_ = tt.sum(
            selected_trial_lambda.dimshuffle(0, 3, 1, 2, "x")
            * weight_stack.dimshuffle(0, 1, "x", 2, 3),
            axis=3,
        )

        # Add observations
        observation = pm.Poisson("obs", lambda_, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoissonTrialSwitch.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (2, 5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = AllTastePoissonTrialSwitch(
        test_data, self.switch_components, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "nrn_lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "tau_trial" in trace.varnames
    assert "state_lambda" in trace.varnames
    assert "taste_lambda" in trace.varnames

    print("Test for AllTastePoissonTrialSwitch passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.AllTastePoissonVarsigFixed" class="doc doc-heading">
            <code>AllTastePoissonVarsigFixed</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>** Model to fit changepoint to all tastes with fixed sigmoid **
** Largely taken from "_v1/poisson_all_tastes_changepoint_model.py"</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class AllTastePoissonVarsigFixed(ChangepointModel):
    """
    ** Model to fit changepoint to all tastes with fixed sigmoid **
    ** Largely taken from "_v1/poisson_all_tastes_changepoint_model.py"
    """

    def __init__(self, data_array, n_states, inds_span=1, **kwargs):
        """
        Args:
            data_array (4D Numpy array): tastes, trials, neurons, time_bins
            n_states (int): Number of states to model
            inds_span(float): Number of indices to cover 5-95% change in sigmoid
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states
        self.inds_span = inds_span

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states
        inds_span = self.inds_span

        # Unroll arrays along taste axis
        data_array_long = np.concatenate(data_array, axis=0)

        # Find mean firing for initial values
        tastes = data_array.shape[0]
        length = data_array.shape[-1]
        nrns = data_array.shape[2]
        trials = data_array.shape[1]

        split_list = np.array_split(data_array, n_states, axis=-1)
        # Cut all to the same size
        min_val = min([x.shape[-1] for x in split_list])
        split_array = np.array([x[..., :min_val] for x in split_list])
        mean_vals = np.mean(split_array, axis=(2, -1)).swapaxes(0, 1)
        mean_vals += 0.01  # To avoid zero starting prob
        mean_nrn_vals = np.mean(mean_vals, axis=(0, 1))

        # Find evenly spaces switchpoints for initial values
        idx = np.arange(data_array.shape[-1])  # Index
        array_idx = np.broadcast_to(idx, data_array_long.shape)
        even_switches = np.linspace(0, idx.max(), n_states + 1)
        even_switches_normal = even_switches / np.max(even_switches)

        taste_label = np.repeat(
            np.arange(data_array.shape[0]), data_array.shape[1])
        trial_num = array_idx.shape[0]

        # Define sigmoid with given sharpness
        sig_b = inds_to_b(inds_span)

        def sigmoid(x):
            b_temp = tt.tile(
                np.array(sig_b)[None, None, None], x.tag.test_value.shape)
            return 1 / (1 + tt.exp(-b_temp * x))

        # Being constructing model
        with pm.Model() as model:
            # Hierarchical firing rates
            # Refer to model diagram
            # Mean firing rate of neuron AT ALL TIMES
            lambda_nrn = pm.Exponential(
                "lambda_nrn", 1 / mean_nrn_vals, shape=(mean_vals.shape[-1])
            )
            # Priors for each state, derived from each neuron
            # Mean firing rate of neuron IN EACH STATE (averaged across tastes)
            lambda_state = pm.Exponential(
                "lambda_state", lambda_nrn, shape=(mean_vals.shape[1:]))
            # Mean firing rate of neuron PER STATE PER TASTE
            lambda_latent = pm.Exponential(
                "lambda",
                lambda_state[np.newaxis, :, :],
                initval=mean_vals,
                shape=(mean_vals.shape),
            )

            # Changepoint time variable
            # INDEPENDENT TAU FOR EVERY TRIAL
            a = pm.HalfNormal("a_tau", 3.0, shape=n_states - 1)
            b = pm.HalfNormal("b_tau", 3.0, shape=n_states - 1)

            # Stack produces n_states x trials --&gt; That gets transposed
            # to trials x n_states and gets sorted along n_states (axis=-1)
            # Sort should work the same way as the Ordered transform --&gt;
            # see rv_sort_test.ipynb
            tau_latent = pm.Beta(
                "tau_latent",
                a,
                b,
                shape=(trial_num, n_states - 1),
                initval=tt.tile(even_switches_normal[1:(
                    n_states)], (array_idx.shape[0], 1)),
            ).sort(axis=-1)

            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            weight_stack = sigmoid(idx[np.newaxis, :] - tau[:, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((tastes * trials, 1, length)), weight_stack], axis=1
            )
            inverse_stack = 1 - weight_stack[:, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((tastes * trials, 1, length))], axis=1
            )
            weight_stack = weight_stack * inverse_stack
            weight_stack = tt.tile(
                weight_stack[:, :, None, :], (1, 1, nrns, 1))

            lambda_latent = lambda_latent.dimshuffle(2, 0, 1)
            lambda_latent = tt.repeat(lambda_latent, trials, axis=1)
            lambda_latent = tt.tile(
                lambda_latent[..., None], (1, 1, 1, length))
            lambda_latent = lambda_latent.dimshuffle(1, 2, 0, 3)
            lambda_ = tt.sum(lambda_latent * weight_stack, axis=1)

            observation = pm.Poisson("obs", lambda_, observed=data_array_long)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (2, 5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = AllTastePoissonVarsigFixed(
            test_data, self.n_states, self.inds_span)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "lambda_nrn" in trace.varnames
        assert "lambda_state" in trace.varnames

        print("Test for AllTastePoissonVarsigFixed passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoissonVarsigFixed.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, inds_span=1, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>4D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tastes, trials, neurons, time_bins</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>inds_span</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of indices to cover 5-95% change in sigmoid</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, inds_span=1, **kwargs):
    """
    Args:
        data_array (4D Numpy array): tastes, trials, neurons, time_bins
        n_states (int): Number of states to model
        inds_span(float): Number of indices to cover 5-95% change in sigmoid
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states
    self.inds_span = inds_span</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoissonVarsigFixed.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states
    inds_span = self.inds_span

    # Unroll arrays along taste axis
    data_array_long = np.concatenate(data_array, axis=0)

    # Find mean firing for initial values
    tastes = data_array.shape[0]
    length = data_array.shape[-1]
    nrns = data_array.shape[2]
    trials = data_array.shape[1]

    split_list = np.array_split(data_array, n_states, axis=-1)
    # Cut all to the same size
    min_val = min([x.shape[-1] for x in split_list])
    split_array = np.array([x[..., :min_val] for x in split_list])
    mean_vals = np.mean(split_array, axis=(2, -1)).swapaxes(0, 1)
    mean_vals += 0.01  # To avoid zero starting prob
    mean_nrn_vals = np.mean(mean_vals, axis=(0, 1))

    # Find evenly spaces switchpoints for initial values
    idx = np.arange(data_array.shape[-1])  # Index
    array_idx = np.broadcast_to(idx, data_array_long.shape)
    even_switches = np.linspace(0, idx.max(), n_states + 1)
    even_switches_normal = even_switches / np.max(even_switches)

    taste_label = np.repeat(
        np.arange(data_array.shape[0]), data_array.shape[1])
    trial_num = array_idx.shape[0]

    # Define sigmoid with given sharpness
    sig_b = inds_to_b(inds_span)

    def sigmoid(x):
        b_temp = tt.tile(
            np.array(sig_b)[None, None, None], x.tag.test_value.shape)
        return 1 / (1 + tt.exp(-b_temp * x))

    # Being constructing model
    with pm.Model() as model:
        # Hierarchical firing rates
        # Refer to model diagram
        # Mean firing rate of neuron AT ALL TIMES
        lambda_nrn = pm.Exponential(
            "lambda_nrn", 1 / mean_nrn_vals, shape=(mean_vals.shape[-1])
        )
        # Priors for each state, derived from each neuron
        # Mean firing rate of neuron IN EACH STATE (averaged across tastes)
        lambda_state = pm.Exponential(
            "lambda_state", lambda_nrn, shape=(mean_vals.shape[1:]))
        # Mean firing rate of neuron PER STATE PER TASTE
        lambda_latent = pm.Exponential(
            "lambda",
            lambda_state[np.newaxis, :, :],
            initval=mean_vals,
            shape=(mean_vals.shape),
        )

        # Changepoint time variable
        # INDEPENDENT TAU FOR EVERY TRIAL
        a = pm.HalfNormal("a_tau", 3.0, shape=n_states - 1)
        b = pm.HalfNormal("b_tau", 3.0, shape=n_states - 1)

        # Stack produces n_states x trials --&gt; That gets transposed
        # to trials x n_states and gets sorted along n_states (axis=-1)
        # Sort should work the same way as the Ordered transform --&gt;
        # see rv_sort_test.ipynb
        tau_latent = pm.Beta(
            "tau_latent",
            a,
            b,
            shape=(trial_num, n_states - 1),
            initval=tt.tile(even_switches_normal[1:(
                n_states)], (array_idx.shape[0], 1)),
        ).sort(axis=-1)

        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        weight_stack = sigmoid(idx[np.newaxis, :] - tau[:, :, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((tastes * trials, 1, length)), weight_stack], axis=1
        )
        inverse_stack = 1 - weight_stack[:, 1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((tastes * trials, 1, length))], axis=1
        )
        weight_stack = weight_stack * inverse_stack
        weight_stack = tt.tile(
            weight_stack[:, :, None, :], (1, 1, nrns, 1))

        lambda_latent = lambda_latent.dimshuffle(2, 0, 1)
        lambda_latent = tt.repeat(lambda_latent, trials, axis=1)
        lambda_latent = tt.tile(
            lambda_latent[..., None], (1, 1, 1, length))
        lambda_latent = lambda_latent.dimshuffle(1, 2, 0, 3)
        lambda_ = tt.sum(lambda_latent * weight_stack, axis=1)

        observation = pm.Poisson("obs", lambda_, observed=data_array_long)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.AllTastePoissonVarsigFixed.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (2, 5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = AllTastePoissonVarsigFixed(
        test_data, self.n_states, self.inds_span)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "lambda_nrn" in trace.varnames
    assert "lambda_state" in trace.varnames

    print("Test for AllTastePoissonVarsigFixed passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.CategoricalChangepoint2D" class="doc doc-heading">
            <code>CategoricalChangepoint2D</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for categorical data changepoint detection on 2D arrays.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class CategoricalChangepoint2D(ChangepointModel):
    """Model for categorical data changepoint detection on 2D arrays."""

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (2D Numpy array): trials x length
                - Each element is a postive integer representing a category
            n_states (int): Number of states to model
            **kwargs: Additional arguments

        """

        super().__init__(**kwargs)
        # Make sure data array is int
        if not np.issubdtype(data_array.dtype, np.integer):
            raise ValueError(
                "Data array must contain integer category values.")
        # Check that data_array is 2D
        if data_array.ndim != 2:
            # If 3D, take the first trial/dimension to make it 2D
            if data_array.ndim == 3:
                data_array = data_array[0]
            else:
                raise ValueError("Data array must be 2D (trials x length).")
        self.data_array = data_array
        self.n_states = n_states

    def generate_model(self):
        data_array = self.data_array
        n_states = self.n_states
        trials, length = data_array.shape
        features = len(np.unique(data_array))

        # If features in data_array are not continuous integer values, map them
        feature_set = np.unique(data_array)
        if not np.array_equal(feature_set, np.arange(len(feature_set))):
            # Create a mapping from original categories to continuous integers
            category_map = {cat: i for i, cat in enumerate(feature_set)}
            data_array = np.vectorize(category_map.get)(data_array)

        idx = np.arange(length)
        flat_data_array = data_array.reshape((trials * length,))

        with pm.Model() as model:
            p = pm.Dirichlet("p", a=np.ones(
                (n_states, features)), shape=(n_states, features))

            # Infer changepoint locations
            a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)
            # Shape: trials x changepoints
            tau_latent = pm.Beta("tau_latent", a_tau, b_tau, shape=(trials, n_states - 1)).sort(
                axis=-1
            )

            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((trials, 1, length)), weight_stack], axis=1)
            inverse_stack = 1 - weight_stack[:, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((trials, 1, length))], axis=1)
            weight_stack = np.multiply(weight_stack, inverse_stack)

            # shapes:
            #   - weight_stack: trials x states x length
            #   - p : states x features

            # shape: trials x length x features
            lambda_ = tt.tensordot(weight_stack, p, [1, 0])

            flat_lambda = lambda_.reshape((trials * length, features))

            # Use categorical likelihood
            # data_array = trials x length
            category = pm.Categorical(
                "category", p=flat_lambda, observed=flat_data_array)

        return model

    def test(self):
        test_data = np.random.randint(0, self.n_states, size=(5, 100))
        test_model = CategoricalChangepoint2D(test_data, self.n_states)
        model = test_model.generate_model()
        with model:
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)
        assert "p" in trace.varnames
        assert "tau" in trace.varnames
        print("Test for CategoricalChangepoint2D passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.CategoricalChangepoint2D.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>2D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x length
- Each element is a postive integer representing a category</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (2D Numpy array): trials x length
            - Each element is a postive integer representing a category
        n_states (int): Number of states to model
        **kwargs: Additional arguments

    """

    super().__init__(**kwargs)
    # Make sure data array is int
    if not np.issubdtype(data_array.dtype, np.integer):
        raise ValueError(
            "Data array must contain integer category values.")
    # Check that data_array is 2D
    if data_array.ndim != 2:
        # If 3D, take the first trial/dimension to make it 2D
        if data_array.ndim == 3:
            data_array = data_array[0]
        else:
            raise ValueError("Data array must be 2D (trials x length).")
    self.data_array = data_array
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.ChangepointModel" class="doc doc-heading">
            <code>ChangepointModel</code>


</h2>


    <div class="doc doc-contents ">



        <p>Base class for all changepoint models</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class ChangepointModel:
    """Base class for all changepoint models"""

    def __init__(self, **kwargs):
        """Initialize model with keyword arguments"""
        self.kwargs = kwargs

    def generate_model(self):
        """Generate pymc model - to be implemented by subclasses"""
        raise NotImplementedError("Subclasses must implement generate_model()")

    def test(self):
        """Test model functionality - to be implemented by subclasses"""
        raise NotImplementedError("Subclasses must implement test()")</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.ChangepointModel.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(**kwargs)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize model with keyword arguments</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, **kwargs):
    """Initialize model with keyword arguments"""
    self.kwargs = kwargs</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.ChangepointModel.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Generate pymc model - to be implemented by subclasses</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """Generate pymc model - to be implemented by subclasses"""
    raise NotImplementedError("Subclasses must implement generate_model()")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.ChangepointModel.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test model functionality - to be implemented by subclasses</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test model functionality - to be implemented by subclasses"""
    raise NotImplementedError("Subclasses must implement test()")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.GaussianChangepointMean2D" class="doc doc-heading">
            <code>GaussianChangepointMean2D</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for gaussian data on 2D array detecting changes only in
the mean.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class GaussianChangepointMean2D(ChangepointModel):
    """Model for gaussian data on 2D array detecting changes only in
    the mean.
    """

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (2D Numpy array): &lt;dimension&gt; x time
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, n_states, axis=-1)]
        ).T
        mean_vals += 0.01  # To avoid zero starting prob

        y_dim = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        with pm.Model() as model:
            mu = pm.Normal("mu", mu=mean_vals, sigma=1,
                           shape=(y_dim, n_states))
            # One variance for each dimension
            sigma = pm.HalfCauchy("sigma", 3.0, shape=(y_dim))

            a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

            even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
            tau_latent = pm.Beta(
                "tau_latent", a_tau, b_tau, initval=even_switches, shape=(n_states - 1)
            ).sort(axis=-1)

            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((1, length)), weight_stack], axis=0)
            inverse_stack = 1 - weight_stack[1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((1, length))], axis=0)
            weight_stack = np.multiply(weight_stack, inverse_stack)

            mu_latent = mu.dot(weight_stack)
            sigma_latent = sigma.dimshuffle(0, "x")
            observation = pm.Normal(
                "obs", mu=mu_latent, sigma=sigma_latent, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (10, 100), n_states=self.n_states, type="normal")

        # Create model with test data
        test_model = GaussianChangepointMean2D(test_data, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "mu" in trace.varnames
        assert "sigma" in trace.varnames
        assert "tau" in trace.varnames

        print("Test for GaussianChangepointMean2D passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMean2D.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>2D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><dimension> x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (2D Numpy array): &lt;dimension&gt; x time
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMean2D.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, n_states, axis=-1)]
    ).T
    mean_vals += 0.01  # To avoid zero starting prob

    y_dim = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    with pm.Model() as model:
        mu = pm.Normal("mu", mu=mean_vals, sigma=1,
                       shape=(y_dim, n_states))
        # One variance for each dimension
        sigma = pm.HalfCauchy("sigma", 3.0, shape=(y_dim))

        a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
        b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
        tau_latent = pm.Beta(
            "tau_latent", a_tau, b_tau, initval=even_switches, shape=(n_states - 1)
        ).sort(axis=-1)

        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((1, length)), weight_stack], axis=0)
        inverse_stack = 1 - weight_stack[1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((1, length))], axis=0)
        weight_stack = np.multiply(weight_stack, inverse_stack)

        mu_latent = mu.dot(weight_stack)
        sigma_latent = sigma.dimshuffle(0, "x")
        observation = pm.Normal(
            "obs", mu=mu_latent, sigma=sigma_latent, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMean2D.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (10, 100), n_states=self.n_states, type="normal")

    # Create model with test data
    test_model = GaussianChangepointMean2D(test_data, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "mu" in trace.varnames
    assert "sigma" in trace.varnames
    assert "tau" in trace.varnames

    print("Test for GaussianChangepointMean2D passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.GaussianChangepointMeanDirichlet" class="doc doc-heading">
            <code>GaussianChangepointMeanDirichlet</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for gaussian data on 2D array detecting changes only in
the mean. Number of states determined using dirichlet process prior.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class GaussianChangepointMeanDirichlet(ChangepointModel):
    """Model for gaussian data on 2D array detecting changes only in
    the mean. Number of states determined using dirichlet process prior.
    """

    def __init__(self, data_array, max_states=15, **kwargs):
        """
        Args:
            data_array (2D Numpy array): &lt;dimension&gt; x time
            max_states (int): Max number of states to include in truncated dirichlet process
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.max_states = max_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        max_states = self.max_states

        y_dim = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, max_states, axis=-1)]
        ).T
        mean_vals += 0.01  # To avoid zero starting prob
        test_std = np.std(data_array, axis=-1)

        with pm.Model() as model:
            # ===================
            # Emissions Variables
            # ===================
            lambda_latent = pm.Normal(
                "lambda", mu=mean_vals, sigma=10, shape=(y_dim, max_states))
            # One variance for each dimension
            sigma = pm.HalfCauchy("sigma", test_std, shape=(y_dim))

            # =====================
            # Changepoint Variables
            # =====================

            # Hyperpriors on alpha
            a_gamma = pm.Gamma("a_gamma", 10, 1)
            b_gamma = pm.Gamma("b_gamma", 1.5, 1)

            # Concentration parameter for beta
            alpha = pm.Gamma("alpha", a_gamma, b_gamma)

            # Draw beta's to calculate stick lengths
            beta = pm.Beta("beta", 1, alpha, shape=max_states)

            # Calculate stick lengths using stick_breaking process
            w_raw = pm.Deterministic("w_raw", stick_breaking(beta))

            # Make sure lengths add to 1, and scale to length of data
            w_latent = pm.Deterministic("w_latent", w_raw / w_raw.sum())
            tau = pm.Deterministic("tau", tt.cumsum(w_latent * length)[:-1])

            # Weight stack to assign lambda's to point in time
            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((1, length)), weight_stack], axis=0)
            inverse_stack = 1 - weight_stack[1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((1, length))], axis=0)
            weight_stack = np.multiply(weight_stack, inverse_stack)

            # Create timeseries for latent variable (mean emission)
            lambda_ = pm.Deterministic(
                "lambda_", tt.tensordot(
                    lambda_latent, weight_stack, axes=(1, 0))
            )
            sigma_latent = sigma.dimshuffle(0, "x")

            # Likelihood for observations
            observation = pm.Normal(
                "obs", mu=lambda_, sigma=sigma_latent, observed=data_array)
        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array((10, 100), n_states=3, type="normal")

        # Create model with test data
        test_model = GaussianChangepointMeanDirichlet(test_data, max_states=5)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "sigma" in trace.varnames
        assert "tau" in trace.varnames
        assert "w_latent" in trace.varnames

        print("Test for GaussianChangepointMeanDirichlet passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMeanDirichlet.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, max_states=15, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>2D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><dimension> x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>max_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Max number of states to include in truncated dirichlet process</p>
              </div>
            </td>
            <td>
                  <code>15</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, max_states=15, **kwargs):
    """
    Args:
        data_array (2D Numpy array): &lt;dimension&gt; x time
        max_states (int): Max number of states to include in truncated dirichlet process
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.max_states = max_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMeanDirichlet.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    max_states = self.max_states

    y_dim = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, max_states, axis=-1)]
    ).T
    mean_vals += 0.01  # To avoid zero starting prob
    test_std = np.std(data_array, axis=-1)

    with pm.Model() as model:
        # ===================
        # Emissions Variables
        # ===================
        lambda_latent = pm.Normal(
            "lambda", mu=mean_vals, sigma=10, shape=(y_dim, max_states))
        # One variance for each dimension
        sigma = pm.HalfCauchy("sigma", test_std, shape=(y_dim))

        # =====================
        # Changepoint Variables
        # =====================

        # Hyperpriors on alpha
        a_gamma = pm.Gamma("a_gamma", 10, 1)
        b_gamma = pm.Gamma("b_gamma", 1.5, 1)

        # Concentration parameter for beta
        alpha = pm.Gamma("alpha", a_gamma, b_gamma)

        # Draw beta's to calculate stick lengths
        beta = pm.Beta("beta", 1, alpha, shape=max_states)

        # Calculate stick lengths using stick_breaking process
        w_raw = pm.Deterministic("w_raw", stick_breaking(beta))

        # Make sure lengths add to 1, and scale to length of data
        w_latent = pm.Deterministic("w_latent", w_raw / w_raw.sum())
        tau = pm.Deterministic("tau", tt.cumsum(w_latent * length)[:-1])

        # Weight stack to assign lambda's to point in time
        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((1, length)), weight_stack], axis=0)
        inverse_stack = 1 - weight_stack[1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((1, length))], axis=0)
        weight_stack = np.multiply(weight_stack, inverse_stack)

        # Create timeseries for latent variable (mean emission)
        lambda_ = pm.Deterministic(
            "lambda_", tt.tensordot(
                lambda_latent, weight_stack, axes=(1, 0))
        )
        sigma_latent = sigma.dimshuffle(0, "x")

        # Likelihood for observations
        observation = pm.Normal(
            "obs", mu=lambda_, sigma=sigma_latent, observed=data_array)
    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMeanDirichlet.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array((10, 100), n_states=3, type="normal")

    # Create model with test data
    test_model = GaussianChangepointMeanDirichlet(test_data, max_states=5)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "sigma" in trace.varnames
    assert "tau" in trace.varnames
    assert "w_latent" in trace.varnames

    print("Test for GaussianChangepointMeanDirichlet passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.GaussianChangepointMeanVar2D" class="doc doc-heading">
            <code>GaussianChangepointMeanVar2D</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for gaussian data on 2D array detecting changes in both
mean and variance.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class GaussianChangepointMeanVar2D(ChangepointModel):
    """Model for gaussian data on 2D array detecting changes in both
    mean and variance.
    """

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (2D Numpy array): &lt;dimension&gt; x time
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, n_states, axis=-1)]
        ).T
        mean_vals += 0.01  # To avoid zero starting prob

        y_dim = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        with pm.Model() as model:
            mu = pm.Normal("mu", mu=mean_vals, sigma=1,
                           shape=(y_dim, n_states))
            sigma = pm.HalfCauchy("sigma", 3.0, shape=(y_dim, n_states))

            a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

            even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
            tau_latent = pm.Beta(
                "tau_latent", a_tau, b_tau, initval=even_switches, shape=(n_states - 1)
            ).sort(axis=-1)

            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((1, length)), weight_stack], axis=0)
            inverse_stack = 1 - weight_stack[1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((1, length))], axis=0)
            weight_stack = np.multiply(weight_stack, inverse_stack)

            mu_latent = mu.dot(weight_stack)
            sigma_latent = sigma.dot(weight_stack)
            observation = pm.Normal(
                "obs", mu=mu_latent, sigma=sigma_latent, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (10, 100), n_states=self.n_states, type="normal")

        # Create model with test data
        test_model = GaussianChangepointMeanVar2D(test_data, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "mu" in trace.varnames
        assert "sigma" in trace.varnames
        assert "tau" in trace.varnames

        print("Test for GaussianChangepointMeanVar2D passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMeanVar2D.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>2D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><dimension> x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (2D Numpy array): &lt;dimension&gt; x time
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMeanVar2D.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, n_states, axis=-1)]
    ).T
    mean_vals += 0.01  # To avoid zero starting prob

    y_dim = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    with pm.Model() as model:
        mu = pm.Normal("mu", mu=mean_vals, sigma=1,
                       shape=(y_dim, n_states))
        sigma = pm.HalfCauchy("sigma", 3.0, shape=(y_dim, n_states))

        a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
        b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
        tau_latent = pm.Beta(
            "tau_latent", a_tau, b_tau, initval=even_switches, shape=(n_states - 1)
        ).sort(axis=-1)

        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((1, length)), weight_stack], axis=0)
        inverse_stack = 1 - weight_stack[1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((1, length))], axis=0)
        weight_stack = np.multiply(weight_stack, inverse_stack)

        mu_latent = mu.dot(weight_stack)
        sigma_latent = sigma.dot(weight_stack)
        observation = pm.Normal(
            "obs", mu=mu_latent, sigma=sigma_latent, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.GaussianChangepointMeanVar2D.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (10, 100), n_states=self.n_states, type="normal")

    # Create model with test data
    test_model = GaussianChangepointMeanVar2D(test_data, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "mu" in trace.varnames
    assert "sigma" in trace.varnames
    assert "tau" in trace.varnames

    print("Test for GaussianChangepointMeanVar2D passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.PoissonChangepoint1D" class="doc doc-heading">
            <code>PoissonChangepoint1D</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for changepoint detection in 1D Poisson time series</p>
<p>This model detects changepoints in 1D time series data using a Poisson likelihood.
It assumes the data follows a Poisson distribution with different rates in different
segments separated by changepoints.</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class PoissonChangepoint1D(ChangepointModel):
    """Model for changepoint detection in 1D Poisson time series

    This model detects changepoints in 1D time series data using a Poisson likelihood.
    It assumes the data follows a Poisson distribution with different rates in different
    segments separated by changepoints.
    """

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (1D Numpy array): Time series data
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = np.asarray(data_array)
        if self.data_array.ndim != 1:
            raise ValueError("data_array must be 1-dimensional")
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states

        # Calculate initial lambda values by splitting data into segments
        mean_vals = np.array([
            np.mean(x) for x in np.array_split(data_array, n_states)
        ])
        mean_vals += 0.01  # To avoid zero starting prob

        idx = np.arange(len(data_array))
        length = len(data_array)

        with pm.Model() as model:
            # Lambda parameters for each state (Poisson rates)
            lambda_latent = pm.Exponential(
                "lambda", 1 / mean_vals, shape=n_states
            )

            # Changepoint locations
            a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

            # Initialize changepoints evenly across the time series
            even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
            tau_latent = pm.Beta(
                "tau_latent",
                a_tau,
                b_tau,
                initval=even_switches,
                shape=(n_states - 1)
            ).sort(axis=-1)

            # Convert to actual time indices
            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent
            )

            # Create weight matrix for smooth transitions between states
            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, np.newaxis]
            )
            weight_stack = tt.concatenate(
                [np.ones((1, length)), weight_stack], axis=0
            )
            inverse_stack = 1 - weight_stack[1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((1, length))], axis=0
            )
            weight_stack = weight_stack * inverse_stack

            # Calculate time-varying lambda
            lambda_t = lambda_latent.dot(weight_stack)

            # Observation model
            observation = pm.Poisson("obs", lambda_t, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data - 1D array with 100 time points
        test_data = gen_test_array(100, n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = PoissonChangepoint1D(test_data, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames

        print("Test for PoissonChangepoint1D passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.PoissonChangepoint1D.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>1D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Time series data</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (1D Numpy array): Time series data
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = np.asarray(data_array)
    if self.data_array.ndim != 1:
        raise ValueError("data_array must be 1-dimensional")
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.PoissonChangepoint1D.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states

    # Calculate initial lambda values by splitting data into segments
    mean_vals = np.array([
        np.mean(x) for x in np.array_split(data_array, n_states)
    ])
    mean_vals += 0.01  # To avoid zero starting prob

    idx = np.arange(len(data_array))
    length = len(data_array)

    with pm.Model() as model:
        # Lambda parameters for each state (Poisson rates)
        lambda_latent = pm.Exponential(
            "lambda", 1 / mean_vals, shape=n_states
        )

        # Changepoint locations
        a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
        b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

        # Initialize changepoints evenly across the time series
        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
        tau_latent = pm.Beta(
            "tau_latent",
            a_tau,
            b_tau,
            initval=even_switches,
            shape=(n_states - 1)
        ).sort(axis=-1)

        # Convert to actual time indices
        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent
        )

        # Create weight matrix for smooth transitions between states
        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, np.newaxis]
        )
        weight_stack = tt.concatenate(
            [np.ones((1, length)), weight_stack], axis=0
        )
        inverse_stack = 1 - weight_stack[1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((1, length))], axis=0
        )
        weight_stack = weight_stack * inverse_stack

        # Calculate time-varying lambda
        lambda_t = lambda_latent.dot(weight_stack)

        # Observation model
        observation = pm.Poisson("obs", lambda_t, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.PoissonChangepoint1D.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data - 1D array with 100 time points
    test_data = gen_test_array(100, n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = PoissonChangepoint1D(test_data, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames

    print("Test for PoissonChangepoint1D passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.SingleTastePoisson" class="doc doc-heading">
            <code>SingleTastePoisson</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for changepoint on single taste</p>
<p>** Largely taken from "non_hardcoded_changepoint_test_3d.ipynb"
** Note : This model does not have hierarchical structure for emissions</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class SingleTastePoisson(ChangepointModel):
    """Model for changepoint on single taste

    ** Largely taken from "non_hardcoded_changepoint_test_3d.ipynb"
    ** Note : This model does not have hierarchical structure for emissions
    """

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (3D Numpy array): trials x neurons x time
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, n_states, axis=-1)]
        ).T
        mean_vals = np.mean(mean_vals, axis=1)
        mean_vals += 0.01  # To avoid zero starting prob

        nrns = data_array.shape[1]
        trials = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        with pm.Model() as model:
            lambda_latent = pm.Exponential(
                "lambda", 1 / mean_vals, shape=(nrns, n_states))

            a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

            even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
            tau_latent = pm.Beta(
                "tau_latent",
                a_tau,
                b_tau,
                # initval=even_switches,
                shape=(trials, n_states - 1),
            ).sort(axis=-1)

            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((trials, 1, length)), weight_stack], axis=1)
            inverse_stack = 1 - weight_stack[:, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((trials, 1, length))], axis=1)
            weight_stack = np.multiply(weight_stack, inverse_stack)

            lambda_ = tt.tensordot(weight_stack, lambda_latent, [
                                   1, 1]).swapaxes(1, 2)
            observation = pm.Poisson("obs", lambda_, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = SingleTastePoisson(test_data, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames

        print("Test for SingleTastePoisson passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoisson.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x neurons x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (3D Numpy array): trials x neurons x time
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoisson.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, n_states, axis=-1)]
    ).T
    mean_vals = np.mean(mean_vals, axis=1)
    mean_vals += 0.01  # To avoid zero starting prob

    nrns = data_array.shape[1]
    trials = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    with pm.Model() as model:
        lambda_latent = pm.Exponential(
            "lambda", 1 / mean_vals, shape=(nrns, n_states))

        a_tau = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
        b_tau = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
        tau_latent = pm.Beta(
            "tau_latent",
            a_tau,
            b_tau,
            # initval=even_switches,
            shape=(trials, n_states - 1),
        ).sort(axis=-1)

        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, :, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((trials, 1, length)), weight_stack], axis=1)
        inverse_stack = 1 - weight_stack[:, 1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((trials, 1, length))], axis=1)
        weight_stack = np.multiply(weight_stack, inverse_stack)

        lambda_ = tt.tensordot(weight_stack, lambda_latent, [
                               1, 1]).swapaxes(1, 2)
        observation = pm.Poisson("obs", lambda_, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoisson.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = SingleTastePoisson(test_data, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames

    print("Test for SingleTastePoisson passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.SingleTastePoissonDirichlet" class="doc doc-heading">
            <code>SingleTastePoissonDirichlet</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for changepoint on single taste using dirichlet process prior</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class SingleTastePoissonDirichlet(ChangepointModel):
    """
    Model for changepoint on single taste using dirichlet process prior
    """

    def __init__(self, data_array, max_states=10, **kwargs):
        """
        Args:
            data_array (3D Numpy array): trials x neurons x time
            max_states (int): Maximum number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.max_states = max_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        max_states = self.max_states

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, max_states, axis=-1)]
        ).T
        mean_vals = np.mean(mean_vals, axis=1)
        mean_vals += 0.01  # To avoid zero starting prob

        nrns = data_array.shape[1]
        trials = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        with pm.Model() as model:
            # ===================
            # Emissions Variables
            # ===================
            lambda_latent = pm.Exponential(
                "lambda", 1 / mean_vals, shape=(nrns, max_states))

            # =====================
            # Changepoint Variables
            # =====================

            # Hyperpriors on alpha
            a_gamma = pm.Gamma("a_gamma", 10, 1)
            b_gamma = pm.Gamma("b_gamma", 1.5, 1)

            # Concentration parameter for beta
            alpha = pm.Gamma("alpha", a_gamma, b_gamma)

            # Draw beta's to calculate stick lengths
            beta = pm.Beta("beta", 1, alpha, shape=(trials, max_states))

            # Calculate stick lengths using stick_breaking process
            w_raw = pm.Deterministic(
                "w_raw", stick_breaking_trial(beta, trials))

            # Make sure lengths add to 1, and scale to length of data
            w_latent = pm.Deterministic(
                "w_latent", w_raw / w_raw.sum(axis=-1)[:, None])
            tau = pm.Deterministic("tau", tt.cumsum(
                w_latent * length, axis=-1)[:, :-1])

            # =====================
            # Rate over time
            # =====================

            # Weight stack to assign lambda's to point in time
            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((trials, 1, length)), weight_stack], axis=1)
            inverse_stack = 1 - weight_stack[:, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((trials, 1, length))], axis=1)
            # Trials x States x Time
            weight_stack = np.multiply(weight_stack, inverse_stack)

            lambda_ = pm.Deterministic(
                "lambda_",
                tt.tensordot(weight_stack, lambda_latent,
                             [1, 1]).swapaxes(1, 2),
            )

            # =====================
            # Likelihood
            # =====================
            observation = pm.Poisson("obs", lambda_, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array((5, 10, 100), n_states=3, type="poisson")

        # Create model with test data
        test_model = SingleTastePoissonDirichlet(test_data, max_states=5)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "w_latent" in trace.varnames

        print("Test for SingleTastePoissonDirichlet passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonDirichlet.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, max_states=10, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x neurons x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>max_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of states to model</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, max_states=10, **kwargs):
    """
    Args:
        data_array (3D Numpy array): trials x neurons x time
        max_states (int): Maximum number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.max_states = max_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonDirichlet.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    max_states = self.max_states

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, max_states, axis=-1)]
    ).T
    mean_vals = np.mean(mean_vals, axis=1)
    mean_vals += 0.01  # To avoid zero starting prob

    nrns = data_array.shape[1]
    trials = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    with pm.Model() as model:
        # ===================
        # Emissions Variables
        # ===================
        lambda_latent = pm.Exponential(
            "lambda", 1 / mean_vals, shape=(nrns, max_states))

        # =====================
        # Changepoint Variables
        # =====================

        # Hyperpriors on alpha
        a_gamma = pm.Gamma("a_gamma", 10, 1)
        b_gamma = pm.Gamma("b_gamma", 1.5, 1)

        # Concentration parameter for beta
        alpha = pm.Gamma("alpha", a_gamma, b_gamma)

        # Draw beta's to calculate stick lengths
        beta = pm.Beta("beta", 1, alpha, shape=(trials, max_states))

        # Calculate stick lengths using stick_breaking process
        w_raw = pm.Deterministic(
            "w_raw", stick_breaking_trial(beta, trials))

        # Make sure lengths add to 1, and scale to length of data
        w_latent = pm.Deterministic(
            "w_latent", w_raw / w_raw.sum(axis=-1)[:, None])
        tau = pm.Deterministic("tau", tt.cumsum(
            w_latent * length, axis=-1)[:, :-1])

        # =====================
        # Rate over time
        # =====================

        # Weight stack to assign lambda's to point in time
        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, :, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((trials, 1, length)), weight_stack], axis=1)
        inverse_stack = 1 - weight_stack[:, 1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((trials, 1, length))], axis=1)
        # Trials x States x Time
        weight_stack = np.multiply(weight_stack, inverse_stack)

        lambda_ = pm.Deterministic(
            "lambda_",
            tt.tensordot(weight_stack, lambda_latent,
                         [1, 1]).swapaxes(1, 2),
        )

        # =====================
        # Likelihood
        # =====================
        observation = pm.Poisson("obs", lambda_, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonDirichlet.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array((5, 10, 100), n_states=3, type="poisson")

    # Create model with test data
    test_model = SingleTastePoissonDirichlet(test_data, max_states=5)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "w_latent" in trace.varnames

    print("Test for SingleTastePoissonDirichlet passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.SingleTastePoissonTrialSwitch" class="doc doc-heading">
            <code>SingleTastePoissonTrialSwitch</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Assuming only emissions change across trials
Changepoint distribution remains constant</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class SingleTastePoissonTrialSwitch(ChangepointModel):
    """
    Assuming only emissions change across trials
    Changepoint distribution remains constant
    """

    def __init__(self, data_array, switch_components, n_states, **kwargs):
        """
        Args:
            data_array (3D Numpy array): trials x neurons x time
            switch_components (int): Number of trial switch components
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.switch_components = switch_components
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        switch_components = self.switch_components
        n_states = self.n_states

        trial_num, nrn_num, time_bins = data_array.shape

        with pm.Model() as model:
            # Define Emissions

            # nrns
            nrn_lambda = pm.Exponential("nrn_lambda", 10, shape=(nrn_num))

            # nrns x switch_comps
            trial_lambda = pm.Exponential(
                "trial_lambda",
                nrn_lambda.dimshuffle(0, "x"),
                shape=(nrn_num, switch_components),
            )

            # nrns x switch_comps x n_states
            state_lambda = pm.Exponential(
                "state_lambda",
                trial_lambda.dimshuffle(0, 1, "x"),
                shape=(nrn_num, switch_components, n_states),
            )

            # Define Changepoints
            # Assuming distribution of changepoints remains
            # the same across all trials

            a = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
            b = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

            even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
            tau_latent = pm.Beta(
                "tau_latent", a, b,
                # initval=even_switches,
                shape=(trial_num, n_states - 1)
            ).sort(axis=-1)

            # Trials x Changepoints
            tau = pm.Deterministic("tau", time_bins * tau_latent)

            # Define trial switches
            # Will have same structure as regular changepoints

            even_trial_switches = np.linspace(
                0, 1, switch_components + 1)[1:-1]
            tau_trial_latent = pm.Beta(
                "tau_trial_latent",
                1,
                1,
                initval=even_trial_switches,
                shape=(switch_components - 1),
            ).sort(axis=-1)

            # Trial_changepoints
            tau_trial = pm.Deterministic(
                "tau_trial", trial_num * tau_trial_latent)

            trial_idx = np.arange(trial_num)
            trial_selector = tt.math.sigmoid(
                trial_idx[np.newaxis, :] - tau_trial.dimshuffle(0, "x")
            )

            trial_selector = tt.concatenate(
                [np.ones((1, trial_num)), trial_selector], axis=0)
            inverse_trial_selector = 1 - trial_selector[1:, :]
            inverse_trial_selector = tt.concatenate(
                [inverse_trial_selector, np.ones((1, trial_num))], axis=0
            )

            # First, we can "select" sets of emissions depending on trial_changepoints
            # switch_comps x trials
            trial_selector = np.multiply(
                trial_selector, inverse_trial_selector)

            # state_lambda: nrns x switch_comps x states

            # selected_trial_lambda : nrns x states x trials
            selected_trial_lambda = pm.Deterministic(
                "selected_trial_lambda",
                tt.sum(
                    # "nrns" x switch_comps x "states" x trials
                    trial_selector.dimshuffle("x", 0, "x", 1)
                    * state_lambda.dimshuffle(0, 1, 2, "x"),
                    axis=1,
                ),
            )

            # Then, we can select state_emissions for every trial
            idx = np.arange(time_bins)

            # tau : Trials x Changepoints
            weight_stack = tt.math.sigmoid(
                idx[np.newaxis, :] - tau[:, :, np.newaxis])
            weight_stack = tt.concatenate(
                [np.ones((trial_num, 1, time_bins)), weight_stack], axis=1
            )
            inverse_stack = 1 - weight_stack[:, 1:]
            inverse_stack = tt.concatenate(
                [inverse_stack, np.ones((trial_num, 1, time_bins))], axis=1
            )

            # Trials x states x Time
            weight_stack = np.multiply(weight_stack, inverse_stack)

            # Convert selected_trial_lambda : nrns x trials x states x "time"

            # nrns x trials x time
            lambda_ = tt.sum(
                selected_trial_lambda.dimshuffle(0, 2, 1, "x")
                * weight_stack.dimshuffle("x", 0, 1, 2),
                axis=2,
            )

            # Convert to : trials x nrns x time
            lambda_ = lambda_.dimshuffle(1, 0, 2)

            # Add observations
            observation = pm.Poisson("obs", lambda_, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = SingleTastePoissonTrialSwitch(
            test_data, self.switch_components, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "nrn_lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "tau_trial" in trace.varnames
        assert "state_lambda" in trace.varnames

        print("Test for SingleTastePoissonTrialSwitch passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonTrialSwitch.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, switch_components, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x neurons x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>switch_components</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of trial switch components</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, switch_components, n_states, **kwargs):
    """
    Args:
        data_array (3D Numpy array): trials x neurons x time
        switch_components (int): Number of trial switch components
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.switch_components = switch_components
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonTrialSwitch.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    switch_components = self.switch_components
    n_states = self.n_states

    trial_num, nrn_num, time_bins = data_array.shape

    with pm.Model() as model:
        # Define Emissions

        # nrns
        nrn_lambda = pm.Exponential("nrn_lambda", 10, shape=(nrn_num))

        # nrns x switch_comps
        trial_lambda = pm.Exponential(
            "trial_lambda",
            nrn_lambda.dimshuffle(0, "x"),
            shape=(nrn_num, switch_components),
        )

        # nrns x switch_comps x n_states
        state_lambda = pm.Exponential(
            "state_lambda",
            trial_lambda.dimshuffle(0, 1, "x"),
            shape=(nrn_num, switch_components, n_states),
        )

        # Define Changepoints
        # Assuming distribution of changepoints remains
        # the same across all trials

        a = pm.HalfCauchy("a_tau", 3.0, shape=n_states - 1)
        b = pm.HalfCauchy("b_tau", 3.0, shape=n_states - 1)

        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]
        tau_latent = pm.Beta(
            "tau_latent", a, b,
            # initval=even_switches,
            shape=(trial_num, n_states - 1)
        ).sort(axis=-1)

        # Trials x Changepoints
        tau = pm.Deterministic("tau", time_bins * tau_latent)

        # Define trial switches
        # Will have same structure as regular changepoints

        even_trial_switches = np.linspace(
            0, 1, switch_components + 1)[1:-1]
        tau_trial_latent = pm.Beta(
            "tau_trial_latent",
            1,
            1,
            initval=even_trial_switches,
            shape=(switch_components - 1),
        ).sort(axis=-1)

        # Trial_changepoints
        tau_trial = pm.Deterministic(
            "tau_trial", trial_num * tau_trial_latent)

        trial_idx = np.arange(trial_num)
        trial_selector = tt.math.sigmoid(
            trial_idx[np.newaxis, :] - tau_trial.dimshuffle(0, "x")
        )

        trial_selector = tt.concatenate(
            [np.ones((1, trial_num)), trial_selector], axis=0)
        inverse_trial_selector = 1 - trial_selector[1:, :]
        inverse_trial_selector = tt.concatenate(
            [inverse_trial_selector, np.ones((1, trial_num))], axis=0
        )

        # First, we can "select" sets of emissions depending on trial_changepoints
        # switch_comps x trials
        trial_selector = np.multiply(
            trial_selector, inverse_trial_selector)

        # state_lambda: nrns x switch_comps x states

        # selected_trial_lambda : nrns x states x trials
        selected_trial_lambda = pm.Deterministic(
            "selected_trial_lambda",
            tt.sum(
                # "nrns" x switch_comps x "states" x trials
                trial_selector.dimshuffle("x", 0, "x", 1)
                * state_lambda.dimshuffle(0, 1, 2, "x"),
                axis=1,
            ),
        )

        # Then, we can select state_emissions for every trial
        idx = np.arange(time_bins)

        # tau : Trials x Changepoints
        weight_stack = tt.math.sigmoid(
            idx[np.newaxis, :] - tau[:, :, np.newaxis])
        weight_stack = tt.concatenate(
            [np.ones((trial_num, 1, time_bins)), weight_stack], axis=1
        )
        inverse_stack = 1 - weight_stack[:, 1:]
        inverse_stack = tt.concatenate(
            [inverse_stack, np.ones((trial_num, 1, time_bins))], axis=1
        )

        # Trials x states x Time
        weight_stack = np.multiply(weight_stack, inverse_stack)

        # Convert selected_trial_lambda : nrns x trials x states x "time"

        # nrns x trials x time
        lambda_ = tt.sum(
            selected_trial_lambda.dimshuffle(0, 2, 1, "x")
            * weight_stack.dimshuffle("x", 0, 1, 2),
            axis=2,
        )

        # Convert to : trials x nrns x time
        lambda_ = lambda_.dimshuffle(1, 0, 2)

        # Add observations
        observation = pm.Poisson("obs", lambda_, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonTrialSwitch.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = SingleTastePoissonTrialSwitch(
        test_data, self.switch_components, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "nrn_lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "tau_trial" in trace.varnames
    assert "state_lambda" in trace.varnames

    print("Test for SingleTastePoissonTrialSwitch passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.SingleTastePoissonVarsig" class="doc doc-heading">
            <code>SingleTastePoissonVarsig</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for changepoint on single taste
**Uses variables sigmoid slope inferred from data</p>
<p>** Largely taken from "non_hardcoded_changepoint_test_3d.ipynb"
** Note : This model does not have hierarchical structure for emissions</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class SingleTastePoissonVarsig(ChangepointModel):
    """Model for changepoint on single taste
    **Uses variables sigmoid slope inferred from data

    ** Largely taken from "non_hardcoded_changepoint_test_3d.ipynb"
    ** Note : This model does not have hierarchical structure for emissions
    """

    def __init__(self, data_array, n_states, **kwargs):
        """
        Args:
            data_array (3D Numpy array): trials x neurons x time
            n_states (int): Number of states to model
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, n_states, axis=-1)]
        ).T
        mean_vals = np.mean(mean_vals, axis=1)
        mean_vals += 0.01  # To avoid zero starting prob

        lambda_test_vals = np.diff(mean_vals, axis=-1)
        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]

        nrns = data_array.shape[1]
        trials = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        with pm.Model() as model:
            # Sigmoid slope
            sig_b = pm.Normal("sig_b", -1, 2, shape=n_states - 1)

            # Initial value
            s0 = pm.Exponential(
                "state0", 1 / (np.mean(mean_vals)), shape=nrns, initval=mean_vals[:, 0]
            )

            # Changes to lambda
            lambda_diff = pm.Normal(
                "lambda_diff",
                mu=0,
                sigma=10,
                shape=(nrns, n_states - 1),
                initval=lambda_test_vals,
            )

            # This is only here to be extracted at the end of sampling
            # NOT USED DIRECTLY IN MODEL
            lambda_fin = pm.Deterministic(
                "lambda", tt.concatenate(
                    [s0[:, np.newaxis], lambda_diff], axis=-1)
            )

            # Changepoint positions
            a = pm.HalfCauchy("a_tau", 10, shape=n_states - 1)
            b = pm.HalfCauchy("b_tau", 10, shape=n_states - 1)

            tau_latent = pm.Beta(
                "tau_latent", a, b,
                # initval=even_switches,
                shape=(trials, n_states - 1)
            ).sort(axis=-1)
            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            # Mechanical manipulations to generate firing rates
            idx_temp = np.tile(
                idx[np.newaxis, np.newaxis, :], (trials, n_states - 1, 1))
            tau_temp = tt.tile(tau[:, :, np.newaxis], (1, 1, len(idx)))
            sig_b_temp = tt.tile(
                sig_b[np.newaxis, :, np.newaxis], (trials, 1, len(idx)))

            weight_stack = var_sig_exp_tt(idx_temp - tau_temp, sig_b_temp)
            weight_stack_temp = tt.tile(
                weight_stack[:, np.newaxis, :, :], (1, nrns, 1, 1))

            s0_temp = tt.tile(
                s0[np.newaxis, :, np.newaxis, np.newaxis],
                (trials, 1, n_states - 1, len(idx)),
            )
            lambda_diff_temp = tt.tile(
                lambda_diff[np.newaxis, :, :,
                            np.newaxis], (trials, 1, 1, len(idx))
            )

            # Calculate lambda
            lambda_ = pm.Deterministic(
                "lambda_",
                tt.sum(s0_temp + (weight_stack_temp * lambda_diff_temp), axis=2),
            )
            # Bound lambda to prevent the diffs from making it negative
            # Don't let it go down to zero otherwise we have trouble with probabilities
            lambda_bounded = pm.Deterministic(
                "lambda_bounded", tt.switch(lambda_ &gt;= 0.01, lambda_, 0.01)
            )

            # Add observations
            observation = pm.Poisson(
                "obs", lambda_bounded, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = SingleTastePoissonVarsig(test_data, self.n_states)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "sig_b" in trace.varnames

        print("Test for SingleTastePoissonVarsig passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonVarsig.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x neurons x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, **kwargs):
    """
    Args:
        data_array (3D Numpy array): trials x neurons x time
        n_states (int): Number of states to model
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonVarsig.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, n_states, axis=-1)]
    ).T
    mean_vals = np.mean(mean_vals, axis=1)
    mean_vals += 0.01  # To avoid zero starting prob

    lambda_test_vals = np.diff(mean_vals, axis=-1)
    even_switches = np.linspace(0, 1, n_states + 1)[1:-1]

    nrns = data_array.shape[1]
    trials = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    with pm.Model() as model:
        # Sigmoid slope
        sig_b = pm.Normal("sig_b", -1, 2, shape=n_states - 1)

        # Initial value
        s0 = pm.Exponential(
            "state0", 1 / (np.mean(mean_vals)), shape=nrns, initval=mean_vals[:, 0]
        )

        # Changes to lambda
        lambda_diff = pm.Normal(
            "lambda_diff",
            mu=0,
            sigma=10,
            shape=(nrns, n_states - 1),
            initval=lambda_test_vals,
        )

        # This is only here to be extracted at the end of sampling
        # NOT USED DIRECTLY IN MODEL
        lambda_fin = pm.Deterministic(
            "lambda", tt.concatenate(
                [s0[:, np.newaxis], lambda_diff], axis=-1)
        )

        # Changepoint positions
        a = pm.HalfCauchy("a_tau", 10, shape=n_states - 1)
        b = pm.HalfCauchy("b_tau", 10, shape=n_states - 1)

        tau_latent = pm.Beta(
            "tau_latent", a, b,
            # initval=even_switches,
            shape=(trials, n_states - 1)
        ).sort(axis=-1)
        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        # Mechanical manipulations to generate firing rates
        idx_temp = np.tile(
            idx[np.newaxis, np.newaxis, :], (trials, n_states - 1, 1))
        tau_temp = tt.tile(tau[:, :, np.newaxis], (1, 1, len(idx)))
        sig_b_temp = tt.tile(
            sig_b[np.newaxis, :, np.newaxis], (trials, 1, len(idx)))

        weight_stack = var_sig_exp_tt(idx_temp - tau_temp, sig_b_temp)
        weight_stack_temp = tt.tile(
            weight_stack[:, np.newaxis, :, :], (1, nrns, 1, 1))

        s0_temp = tt.tile(
            s0[np.newaxis, :, np.newaxis, np.newaxis],
            (trials, 1, n_states - 1, len(idx)),
        )
        lambda_diff_temp = tt.tile(
            lambda_diff[np.newaxis, :, :,
                        np.newaxis], (trials, 1, 1, len(idx))
        )

        # Calculate lambda
        lambda_ = pm.Deterministic(
            "lambda_",
            tt.sum(s0_temp + (weight_stack_temp * lambda_diff_temp), axis=2),
        )
        # Bound lambda to prevent the diffs from making it negative
        # Don't let it go down to zero otherwise we have trouble with probabilities
        lambda_bounded = pm.Deterministic(
            "lambda_bounded", tt.switch(lambda_ &gt;= 0.01, lambda_, 0.01)
        )

        # Add observations
        observation = pm.Poisson(
            "obs", lambda_bounded, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonVarsig.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = SingleTastePoissonVarsig(test_data, self.n_states)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "sig_b" in trace.varnames

    print("Test for SingleTastePoissonVarsig passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytau.changepoint_model.SingleTastePoissonVarsigFixed" class="doc doc-heading">
            <code>SingleTastePoissonVarsigFixed</code>


</h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="ChangepointModel (pytau.changepoint_model.ChangepointModel)" href="#pytau.changepoint_model.ChangepointModel">ChangepointModel</a></code></p>



        <p>Model for changepoint on single taste
**Uses sigmoid with given slope</p>
<p>** Largely taken from "non_hardcoded_changepoint_test_3d.ipynb"
** Note : This model does not have hierarchical structure for emissions</p>








              <details class="mkdocstrings-source">
                <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
                <pre class="highlight"><code class="language-python">class SingleTastePoissonVarsigFixed(ChangepointModel):
    """Model for changepoint on single taste
    **Uses sigmoid with given slope

    ** Largely taken from "non_hardcoded_changepoint_test_3d.ipynb"
    ** Note : This model does not have hierarchical structure for emissions
    """

    def __init__(self, data_array, n_states, inds_span=1, **kwargs):
        """
        Args:
            data_array (3D Numpy array): trials x neurons x time
            n_states (int): Number of states to model
            inds_span(float) : Number of indices to cover 5-95% change in sigmoid
            **kwargs: Additional arguments
        """
        super().__init__(**kwargs)
        self.data_array = data_array
        self.n_states = n_states
        self.inds_span = inds_span

    def generate_model(self):
        """
        Returns:
            pymc model: Model class containing graph to run inference on
        """
        data_array = self.data_array
        n_states = self.n_states
        inds_span = self.inds_span

        mean_vals = np.array(
            [np.mean(x, axis=-1)
             for x in np.array_split(data_array, n_states, axis=-1)]
        ).T
        mean_vals = np.mean(mean_vals, axis=1)
        mean_vals += 0.01  # To avoid zero starting prob

        lambda_test_vals = np.diff(mean_vals, axis=-1)
        even_switches = np.linspace(0, 1, n_states + 1)[1:-1]

        nrns = data_array.shape[1]
        trials = data_array.shape[0]
        idx = np.arange(data_array.shape[-1])
        length = idx.max() + 1

        # Define sigmoid with given sharpness
        sig_b = inds_to_b(inds_span)

        def sigmoid(x):
            b_temp = tt.tile(
                np.array(sig_b)[None, None, None], x.tag.test_value.shape)
            return 1 / (1 + tt.exp(-b_temp * x))

        with pm.Model() as model:
            # Initial value
            s0 = pm.Exponential(
                "state0", 1 / (np.mean(mean_vals)), shape=nrns, initval=mean_vals[:, 0]
            )

            # Changes to lambda
            lambda_diff = pm.Normal(
                "lambda_diff",
                mu=0,
                sigma=10,
                shape=(nrns, n_states - 1),
                initval=lambda_test_vals,
            )

            # This is only here to be extracted at the end of sampling
            # NOT USED DIRECTLY IN MODEL
            lambda_fin = pm.Deterministic(
                "lambda", tt.concatenate(
                    [s0[:, np.newaxis], lambda_diff], axis=-1)
            )

            # Changepoint positions
            a = pm.HalfCauchy("a_tau", 10, shape=n_states - 1)
            b = pm.HalfCauchy("b_tau", 10, shape=n_states - 1)

            tau_latent = pm.Beta(
                "tau_latent", a, b,
                # initval=even_switches,
                shape=(trials, n_states - 1)
            ).sort(axis=-1)
            tau = pm.Deterministic(
                "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

            # Mechanical manipulations to generate firing rates
            idx_temp = np.tile(
                idx[np.newaxis, np.newaxis, :], (trials, n_states - 1, 1))
            tau_temp = tt.tile(tau[:, :, np.newaxis], (1, 1, len(idx)))

            weight_stack = sigmoid(idx_temp - tau_temp)
            weight_stack_temp = tt.tile(
                weight_stack[:, np.newaxis, :, :], (1, nrns, 1, 1))

            s0_temp = tt.tile(
                s0[np.newaxis, :, np.newaxis, np.newaxis],
                (trials, 1, n_states - 1, len(idx)),
            )
            lambda_diff_temp = tt.tile(
                lambda_diff[np.newaxis, :, :,
                            np.newaxis], (trials, 1, 1, len(idx))
            )

            # Calculate lambda
            lambda_ = pm.Deterministic(
                "lambda_",
                tt.sum(s0_temp + (weight_stack_temp * lambda_diff_temp), axis=2),
            )
            # Bound lambda to prevent the diffs from making it negative
            # Don't let it go down to zero otherwise we have trouble with probabilities
            lambda_bounded = pm.Deterministic(
                "lambda_bounded", tt.switch(lambda_ &gt;= 0.01, lambda_, 0.01)
            )

            # Add observations
            observation = pm.Poisson(
                "obs", lambda_bounded, observed=data_array)

        return model

    def test(self):
        """Test the model with synthetic data"""
        # Generate test data
        test_data = gen_test_array(
            (5, 10, 100), n_states=self.n_states, type="poisson")

        # Create model with test data
        test_model = SingleTastePoissonVarsigFixed(
            test_data, self.n_states, self.inds_span)
        model = test_model.generate_model()

        # Run a minimal inference to verify model works
        with model:
            # Just do a few iterations to test functionality
            inference = pm.ADVI()
            approx = pm.fit(n=10, method=inference)
            trace = approx.sample(draws=10)

        # Check if expected variables are in the trace
        assert "lambda" in trace.varnames
        assert "tau" in trace.varnames
        assert "state0" in trace.varnames

        print("Test for SingleTastePoissonVarsigFixed passed")
        return True</code></pre>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonVarsigFixed.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(data_array, n_states, inds_span=1, **kwargs)</code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x neurons x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>inds_span(float) </code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of indices to cover 5-95% change in sigmoid</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional arguments</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, data_array, n_states, inds_span=1, **kwargs):
    """
    Args:
        data_array (3D Numpy array): trials x neurons x time
        n_states (int): Number of states to model
        inds_span(float) : Number of indices to cover 5-95% change in sigmoid
        **kwargs: Additional arguments
    """
    super().__init__(**kwargs)
    self.data_array = data_array
    self.n_states = n_states
    self.inds_span = inds_span</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonVarsigFixed.generate_model" class="doc doc-heading">
            <code class="highlight language-python">generate_model()</code>

</h3>


    <div class="doc doc-contents ">



    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>pymc model: Model class containing graph to run inference on</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def generate_model(self):
    """
    Returns:
        pymc model: Model class containing graph to run inference on
    """
    data_array = self.data_array
    n_states = self.n_states
    inds_span = self.inds_span

    mean_vals = np.array(
        [np.mean(x, axis=-1)
         for x in np.array_split(data_array, n_states, axis=-1)]
    ).T
    mean_vals = np.mean(mean_vals, axis=1)
    mean_vals += 0.01  # To avoid zero starting prob

    lambda_test_vals = np.diff(mean_vals, axis=-1)
    even_switches = np.linspace(0, 1, n_states + 1)[1:-1]

    nrns = data_array.shape[1]
    trials = data_array.shape[0]
    idx = np.arange(data_array.shape[-1])
    length = idx.max() + 1

    # Define sigmoid with given sharpness
    sig_b = inds_to_b(inds_span)

    def sigmoid(x):
        b_temp = tt.tile(
            np.array(sig_b)[None, None, None], x.tag.test_value.shape)
        return 1 / (1 + tt.exp(-b_temp * x))

    with pm.Model() as model:
        # Initial value
        s0 = pm.Exponential(
            "state0", 1 / (np.mean(mean_vals)), shape=nrns, initval=mean_vals[:, 0]
        )

        # Changes to lambda
        lambda_diff = pm.Normal(
            "lambda_diff",
            mu=0,
            sigma=10,
            shape=(nrns, n_states - 1),
            initval=lambda_test_vals,
        )

        # This is only here to be extracted at the end of sampling
        # NOT USED DIRECTLY IN MODEL
        lambda_fin = pm.Deterministic(
            "lambda", tt.concatenate(
                [s0[:, np.newaxis], lambda_diff], axis=-1)
        )

        # Changepoint positions
        a = pm.HalfCauchy("a_tau", 10, shape=n_states - 1)
        b = pm.HalfCauchy("b_tau", 10, shape=n_states - 1)

        tau_latent = pm.Beta(
            "tau_latent", a, b,
            # initval=even_switches,
            shape=(trials, n_states - 1)
        ).sort(axis=-1)
        tau = pm.Deterministic(
            "tau", idx.min() + (idx.max() - idx.min()) * tau_latent)

        # Mechanical manipulations to generate firing rates
        idx_temp = np.tile(
            idx[np.newaxis, np.newaxis, :], (trials, n_states - 1, 1))
        tau_temp = tt.tile(tau[:, :, np.newaxis], (1, 1, len(idx)))

        weight_stack = sigmoid(idx_temp - tau_temp)
        weight_stack_temp = tt.tile(
            weight_stack[:, np.newaxis, :, :], (1, nrns, 1, 1))

        s0_temp = tt.tile(
            s0[np.newaxis, :, np.newaxis, np.newaxis],
            (trials, 1, n_states - 1, len(idx)),
        )
        lambda_diff_temp = tt.tile(
            lambda_diff[np.newaxis, :, :,
                        np.newaxis], (trials, 1, 1, len(idx))
        )

        # Calculate lambda
        lambda_ = pm.Deterministic(
            "lambda_",
            tt.sum(s0_temp + (weight_stack_temp * lambda_diff_temp), axis=2),
        )
        # Bound lambda to prevent the diffs from making it negative
        # Don't let it go down to zero otherwise we have trouble with probabilities
        lambda_bounded = pm.Deterministic(
            "lambda_bounded", tt.switch(lambda_ &gt;= 0.01, lambda_, 0.01)
        )

        # Add observations
        observation = pm.Poisson(
            "obs", lambda_bounded, observed=data_array)

    return model</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pytau.changepoint_model.SingleTastePoissonVarsigFixed.test" class="doc doc-heading">
            <code class="highlight language-python">test()</code>

</h3>


    <div class="doc doc-contents ">

        <p>Test the model with synthetic data</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def test(self):
    """Test the model with synthetic data"""
    # Generate test data
    test_data = gen_test_array(
        (5, 10, 100), n_states=self.n_states, type="poisson")

    # Create model with test data
    test_model = SingleTastePoissonVarsigFixed(
        test_data, self.n_states, self.inds_span)
    model = test_model.generate_model()

    # Run a minimal inference to verify model works
    with model:
        # Just do a few iterations to test functionality
        inference = pm.ADVI()
        approx = pm.fit(n=10, method=inference)
        trace = approx.sample(draws=10)

    # Check if expected variables are in the trace
    assert "lambda" in trace.varnames
    assert "tau" in trace.varnames
    assert "state0" in trace.varnames

    print("Test for SingleTastePoissonVarsigFixed passed")
    return True</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.advi_fit" class="doc doc-heading">
            <code class="highlight language-python">advi_fit(model, fit, samples, convergence_tol=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convenience function to perform ADVI fit on model</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>model</code>
            </td>
            <td>
                  <code>pymc model</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>model object to run inference on</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>fit</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of iterationst to fit the model for</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>samples</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of samples to draw from fitted model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>model</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>original model on which inference was run,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>approx</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>fitted model,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>lambda_stack</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>array containing lambda (emission) values,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tau_samples,: array containing samples from changepoint distribution</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>model.obs.observations: processed array on which fit was run</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def advi_fit(model, fit, samples, convergence_tol=None):
    """Convenience function to perform ADVI fit on model

    Args:
        model (pymc model): model object to run inference on
        fit (int): Number of iterationst to fit the model for
        samples (int): Number of samples to draw from fitted model

    Returns:
        model: original model on which inference was run,
        approx: fitted model,
        lambda_stack: array containing lambda (emission) values,
        tau_samples,: array containing samples from changepoint distribution
        model.obs.observations: processed array on which fit was run
    """

    if convergence_tol is not None:
        callbacks = [pm.callbacks.CheckParametersConvergence(
            tolerance=convergence_tol)]
        print("Using convergence callback with tolerance:", convergence_tol)
    else:
        callbacks = None
    with model:
        inference = pm.ADVI("full-rank")
        approx = pm.fit(n=fit, method=inference, callbacks=callbacks)
        idata = approx.sample(draws=samples)

    # Check if tau exists in posterior samples (PyMC5 uses InferenceData)
    if "tau" not in idata.posterior.data_vars:
        available_vars = list(idata.posterior.data_vars.keys())
        raise KeyError(
            f"'tau' not found in posterior samples. Available variables: {available_vars}")

    # Extract relevant variables from InferenceData posterior
    try:
        tau_samples = idata.posterior["tau"].values
        # Handle potential dimension issues
        if tau_samples.ndim &gt; 2:
            tau_samples = tau_samples.reshape(-1, tau_samples.shape[-1])
    except Exception as e:
        print(f"Error extracting tau samples: {e}")
        tau_samples = None

    # Get observed data from model (PyMC5 compatible)
    # Since notebooks don't use fit_data, return None to avoid compatibility issues
    observed_data = None

    if "lambda" in idata.posterior.data_vars:
        try:
            lambda_stack = idata.posterior["lambda"].values
            # Handle potential dimension issues
            if lambda_stack.ndim &gt; 3:
                lambda_stack = lambda_stack.reshape(-1,
                                                    *lambda_stack.shape[-2:])
            lambda_stack = lambda_stack.swapaxes(0, 1)
            return model, approx, lambda_stack, tau_samples, observed_data
        except Exception as e:
            print(f"Error extracting lambda samples: {e}")
            return model, approx, None, tau_samples, observed_data

    if "mu" in idata.posterior.data_vars:
        try:
            mu_stack = idata.posterior["mu"].values
            sigma_stack = idata.posterior["sigma"].values
            # Handle potential dimension issues
            if mu_stack.ndim &gt; 3:
                mu_stack = mu_stack.reshape(-1, *mu_stack.shape[-2:])
            if sigma_stack.ndim &gt; 3:
                sigma_stack = sigma_stack.reshape(-1, *sigma_stack.shape[-2:])
            mu_stack = mu_stack.swapaxes(0, 1)
            sigma_stack = sigma_stack.swapaxes(0, 1)
            return model, approx, mu_stack, sigma_stack, tau_samples, observed_data
        except Exception as e:
            print(f"Error extracting mu/sigma samples: {e}")
            return model, approx, None, None, tau_samples, observed_data

    # Fallback - return what we can
    return model, approx, None, tau_samples, observed_data</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.all_taste_poisson" class="doc doc-heading">
            <code class="highlight language-python">all_taste_poisson(data_array, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def all_taste_poisson(data_array, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = AllTastePoisson(data_array, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.all_taste_poisson_trial_switch" class="doc doc-heading">
            <code class="highlight language-python">all_taste_poisson_trial_switch(data_array, switch_components, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def all_taste_poisson_trial_switch(data_array, switch_components, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = AllTastePoissonTrialSwitch(
        data_array, switch_components, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.all_taste_poisson_varsig_fixed" class="doc doc-heading">
            <code class="highlight language-python">all_taste_poisson_varsig_fixed(data_array, n_states, inds_span=1, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def all_taste_poisson_varsig_fixed(data_array, n_states, inds_span=1, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = AllTastePoissonVarsigFixed(
        data_array, n_states, inds_span, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.dpp_fit" class="doc doc-heading">
            <code class="highlight language-python">dpp_fit(model, n_chains=24, n_cores=1, tune=500, draws=500, use_numpyro=False)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convenience function to fit DPP model</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def dpp_fit(model, n_chains=24, n_cores=1, tune=500, draws=500, use_numpyro=False):
    """Convenience function to fit DPP model"""
    if not use_numpyro:
        with model:
            dpp_trace = pm.sample(
                tune=tune,
                draws=draws,
                target_accept=0.95,
                chains=n_chains,
                cores=n_cores,
                return_inferencedata=False,
            )
    else:
        with model:
            dpp_trace = pm.sample(
                nuts_sampler="numpyro",
                tune=tune,
                draws=draws,
                target_accept=0.95,
                chains=n_chains,
                cores=n_cores,
                return_inferencedata=False,
            )
    return dpp_trace</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.extract_inferred_values" class="doc doc-heading">
            <code class="highlight language-python">extract_inferred_values(trace)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convenience function to extract inferred values from ADVI fit</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>trace</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trace</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dictionary of inferred values</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def extract_inferred_values(trace):
    """Convenience function to extract inferred values from ADVI fit

    Args:
        trace (dict): trace

    Returns:
        dict: dictionary of inferred values
    """
    # Extract relevant variables from trace
    out_dict = dict(tau_samples=trace["tau"])
    if "lambda" in trace.varnames:
        out_dict["lambda_stack"] = trace["lambda"].swapaxes(0, 1)
    if "mu" in trace.varnames:
        out_dict["mu_stack"] = trace["mu"].swapaxes(0, 1)
        out_dict["sigma_stack"] = trace["sigma"].swapaxes(0, 1)
    return out_dict</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.find_best_states" class="doc doc-heading">
            <code class="highlight language-python">find_best_states(data, model_generator, n_fit, n_samples, min_states=2, max_states=10, convergence_tol=None)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convenience function to find best number of states for model</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>data</code>
            </td>
            <td>
                  <code><span title="array">array</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>array on which to run inference</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>model_generator</code>
            </td>
            <td>
                  <code><span title="function">function</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>function that generates model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_fit</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of iterationst to fit the model for</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_samples</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of samples to draw from fitted model</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>min_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Minimum number of states to test</p>
              </div>
            </td>
            <td>
                  <code>2</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>max_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of states to test</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>convergence_tol</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Tolerance for convergence. If None, will not check for convergence.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>best_model</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>model with best number of states,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>model_list</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>list of models with different number of states,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>elbo_values</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>list of elbo values for different number of states</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def find_best_states(
        data,
        model_generator,
        n_fit, n_samples,
        min_states=2,
        max_states=10,
        convergence_tol=None,
):
    """Convenience function to find best number of states for model

    Args:
        data (array): array on which to run inference
        model_generator (function): function that generates model
        n_fit (int): Number of iterationst to fit the model for
        n_samples (int): Number of samples to draw from fitted model
        min_states (int): Minimum number of states to test
        max_states (int): Maximum number of states to test
        convergence_tol (float): Tolerance for convergence. If None, will not check for convergence.

    Returns:
        best_model: model with best number of states,
        model_list: list of models with different number of states,
        elbo_values: list of elbo values for different number of states
    """
    n_state_array = np.arange(min_states, max_states + 1)
    elbo_values = []
    model_list = []
    for n_states in tqdm(n_state_array):
        print(f"Fitting model with {n_states} states")
        # Have to use int instead of np.int64
        model = model_generator(data, int(n_states))
        model, approx = advi_fit(model, n_fit, n_samples, convergence_tol)[:2]
        elbo_values.append(approx.hist[-1])
        model_list.append(model)
    best_model = model_list[np.argmin(elbo_values)]
    return best_model, model_list, elbo_values</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.gaussian_changepoint_mean_2d" class="doc doc-heading">
            <code class="highlight language-python">gaussian_changepoint_mean_2d(data_array, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def gaussian_changepoint_mean_2d(data_array, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = GaussianChangepointMean2D(data_array, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.gaussian_changepoint_mean_dirichlet" class="doc doc-heading">
            <code class="highlight language-python">gaussian_changepoint_mean_dirichlet(data_array, max_states=15, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def gaussian_changepoint_mean_dirichlet(data_array, max_states=15, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = GaussianChangepointMeanDirichlet(
        data_array, max_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.gaussian_changepoint_mean_var_2d" class="doc doc-heading">
            <code class="highlight language-python">gaussian_changepoint_mean_var_2d(data_array, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def gaussian_changepoint_mean_var_2d(data_array, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = GaussianChangepointMeanVar2D(data_array, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.gen_test_array" class="doc doc-heading">
            <code class="highlight language-python">gen_test_array(array_size, n_states, type='poisson')</code>

</h2>


    <div class="doc doc-contents ">

        <p>Generate test array for model fitting
Last 2 dimensions consist of a single trial
Time will always be last dimension</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>array_size</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span> or <span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Size of array to generate. If int, generates 1D array.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>n_states</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of states to generate</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>type</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Type of data to generate
- normal
- poisson</p>
              </div>
            </td>
            <td>
                  <code>&#39;poisson&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def gen_test_array(array_size, n_states, type="poisson"):
    """
    Generate test array for model fitting
    Last 2 dimensions consist of a single trial
    Time will always be last dimension

    Args:
        array_size (tuple or int): Size of array to generate. If int, generates 1D array.
        n_states (int): Number of states to generate
        type (str): Type of data to generate
            - normal
            - poisson
    """
    # Handle 1D case
    if isinstance(array_size, int):
        assert array_size &gt; n_states, "Array too small for states"
        assert type in [
            "normal", "poisson"], "Invalid type, please use normal or poisson"

        # Generate transition times for 1D case
        transition_times = np.random.random(n_states)
        transition_times = np.cumsum(transition_times)
        transition_times = transition_times / transition_times.max()
        transition_times *= array_size
        transition_times = transition_times.astype(int)

        # Generate state bounds
        state_bounds = np.zeros(n_states + 1, dtype=int)
        state_bounds[1:] = transition_times
        state_bounds[-1] = array_size

        # Generate state rates
        lambda_vals = np.random.exponential(2.0, n_states) + 0.5

        # Generate 1D array
        rate_array = np.zeros(array_size)
        for i in range(n_states):
            start_idx = state_bounds[i]
            end_idx = state_bounds[i + 1]
            rate_array[start_idx:end_idx] = lambda_vals[i]

        if type == "poisson":
            return np.random.poisson(rate_array)
        else:
            return np.random.normal(loc=rate_array, scale=0.1)

    # Handle multi-dimensional case (existing code)
    assert array_size[-1] &gt; n_states, "Array too small for states"
    assert type in [
        "normal", "poisson"], "Invalid type, please use normal or poisson"

    # Generate transition times
    transition_times = np.random.random((*array_size[:-2], n_states))
    transition_times = np.cumsum(transition_times, axis=-1)
    transition_times = transition_times / \
        transition_times.max(axis=-1, keepdims=True)
    transition_times *= array_size[-1]
    transition_times = np.vectorize(int)(transition_times)

    # Generate state bounds
    state_bounds = np.zeros((*array_size[:-2], n_states + 1), dtype=int)
    state_bounds[..., 1:] = transition_times

    # Generate state rates
    lambda_vals = np.random.random((*array_size[:-1], n_states))

    # Generate array
    rate_array = np.zeros(array_size)
    inds = list(np.ndindex(lambda_vals.shape))
    for this_ind in inds:
        this_lambda = lambda_vals[this_ind[:-2]][:, this_ind[-1]]
        this_state_bounds = [
            state_bounds[(*this_ind[:-2], this_ind[-1])],
            state_bounds[(*this_ind[:-2], this_ind[-1] + 1)],
        ]
        rate_array[this_ind[:-2]][:,
                                  slice(*this_state_bounds)] = this_lambda[:, None]

    if type == "poisson":
        return np.random.poisson(rate_array)
    else:
        return np.random.normal(loc=rate_array, scale=0.1)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.mcmc_fit" class="doc doc-heading">
            <code class="highlight language-python">mcmc_fit(model, samples)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Convenience function to perform ADVI fit on model</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>model</code>
            </td>
            <td>
                  <code>pymc model</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>model object to run inference on</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>samples</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of samples to draw using MCMC</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>model</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>original model on which inference was run,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>trace</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>samples drawn from MCMC,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>lambda_stack</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>array containing lambda (emission) values,</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tau_samples,: array containing samples from changepoint distribution</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>model.obs.observations: processed array on which fit was run</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def mcmc_fit(model, samples):
    """Convenience function to perform ADVI fit on model

    Args:
        model (pymc model): model object to run inference on
        samples (int): Number of samples to draw using MCMC

    Returns:
        model: original model on which inference was run,
        trace:  samples drawn from MCMC,
        lambda_stack: array containing lambda (emission) values,
        tau_samples,: array containing samples from changepoint distribution
        model.obs.observations: processed array on which fit was run
    """

    with model:
        sampler_kwargs = {"cores": 1, "chains": 4}
        idata = pm.sample(draws=samples, **sampler_kwargs)
        # Thin the samples (every 10th sample)
        idata_thinned = idata.sel(draw=slice(None, None, 10))

    # Extract relevant variables from InferenceData posterior
    try:
        tau_samples = idata_thinned.posterior["tau"].values
        # Handle potential dimension issues
        if tau_samples.ndim &gt; 2:
            tau_samples = tau_samples.reshape(-1, tau_samples.shape[-1])
    except Exception as e:
        print(f"Error extracting tau samples: {e}")
        tau_samples = None

    # Get observed data from model (PyMC5 compatible)
    # Since notebooks don't use fit_data, return None to avoid compatibility issues
    observed_data = None

    if "lambda" in idata_thinned.posterior.data_vars:
        try:
            lambda_stack = idata_thinned.posterior["lambda"].values
            # Handle potential dimension issues
            if lambda_stack.ndim &gt; 3:
                lambda_stack = lambda_stack.reshape(-1,
                                                    *lambda_stack.shape[-2:])
            lambda_stack = lambda_stack.swapaxes(0, 1)
            return model, idata_thinned, lambda_stack, tau_samples, observed_data
        except Exception as e:
            print(f"Error extracting lambda samples: {e}")
            return model, idata_thinned, None, tau_samples, observed_data

    if "mu" in idata_thinned.posterior.data_vars:
        try:
            mu_stack = idata_thinned.posterior["mu"].values
            sigma_stack = idata_thinned.posterior["sigma"].values
            # Handle potential dimension issues
            if mu_stack.ndim &gt; 3:
                mu_stack = mu_stack.reshape(-1, *mu_stack.shape[-2:])
            if sigma_stack.ndim &gt; 3:
                sigma_stack = sigma_stack.reshape(-1, *sigma_stack.shape[-2:])
            mu_stack = mu_stack.swapaxes(0, 1)
            sigma_stack = sigma_stack.swapaxes(0, 1)
            return model, idata_thinned, mu_stack, sigma_stack, tau_samples, observed_data
        except Exception as e:
            print(f"Error extracting mu/sigma samples: {e}")
            return model, idata_thinned, None, None, tau_samples, observed_data

    # Fallback - return what we can
    return model, idata_thinned, None, tau_samples, observed_data</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.poisson_changepoint_1d" class="doc doc-heading">
            <code class="highlight language-python">poisson_changepoint_1d(data_array, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def poisson_changepoint_1d(data_array, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = PoissonChangepoint1D(data_array, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.run_all_tests" class="doc doc-heading">
            <code class="highlight language-python">run_all_tests()</code>

</h2>


    <div class="doc doc-contents ">

        <p>Run tests for all model classes</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def run_all_tests():
    """Run tests for all model classes"""
    # Create test data
    test_data_1d = gen_test_array(100, n_states=3, type="poisson")
    test_data_2d = gen_test_array((10, 100), n_states=3, type="normal")
    test_data_3d = gen_test_array((5, 10, 100), n_states=3, type="poisson")
    test_data_4d = gen_test_array((2, 5, 10, 100), n_states=3, type="poisson")

    # Test each model class
    models_to_test = [
        PoissonChangepoint1D(test_data_1d, 3),
        GaussianChangepointMeanVar2D(test_data_2d, 3),
        GaussianChangepointMeanDirichlet(test_data_2d, 5),
        GaussianChangepointMean2D(test_data_2d, 3),
        SingleTastePoissonDirichlet(test_data_3d, 5),
        SingleTastePoisson(test_data_3d, 3),
        SingleTastePoissonVarsig(test_data_3d, 3),
        SingleTastePoissonVarsigFixed(test_data_3d, 3, 1),
        SingleTastePoissonTrialSwitch(test_data_3d, 2, 3),
        AllTastePoisson(test_data_4d, 3),
        AllTastePoissonVarsigFixed(test_data_4d, 3, 1),
        AllTastePoissonTrialSwitch(test_data_4d, 2, 3),
    ]

    failed_tests = []
    pbar = tqdm(models_to_test, total=len(models_to_test))
    for model in pbar:
        try:
            model.test()
            pbar.set_description(f"Test passed for {model.__class__.__name__}")
        except Exception as e:
            failed_tests.append(model.__class__.__name__)
            print(f"Test failed for {model.__class__.__name__}: {str(e)}")

    print("All tests completed")
    if failed_tests:
        print("Failed tests:", failed_tests)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.single_taste_poisson" class="doc doc-heading">
            <code class="highlight language-python">single_taste_poisson(data_array, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def single_taste_poisson(data_array, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = SingleTastePoisson(data_array, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.single_taste_poisson_dirichlet" class="doc doc-heading">
            <code class="highlight language-python">single_taste_poisson_dirichlet(data_array, max_states=10, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def single_taste_poisson_dirichlet(data_array, max_states=10, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = SingleTastePoissonDirichlet(data_array, max_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.single_taste_poisson_trial_switch" class="doc doc-heading">
            <code class="highlight language-python">single_taste_poisson_trial_switch(data_array, switch_components, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def single_taste_poisson_trial_switch(data_array, switch_components, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = SingleTastePoissonTrialSwitch(
        data_array, switch_components, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.single_taste_poisson_varsig" class="doc doc-heading">
            <code class="highlight language-python">single_taste_poisson_varsig(data_array, n_states, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def single_taste_poisson_varsig(data_array, n_states, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = SingleTastePoissonVarsig(data_array, n_states, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.single_taste_poisson_varsig_fixed" class="doc doc-heading">
            <code class="highlight language-python">single_taste_poisson_varsig_fixed(data_array, n_states, inds_span=1, **kwargs)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Wrapper function for backward compatibility</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def single_taste_poisson_varsig_fixed(data_array, n_states, inds_span=1, **kwargs):
    """Wrapper function for backward compatibility"""
    model_class = SingleTastePoissonVarsigFixed(
        data_array, n_states, inds_span, **kwargs)
    return model_class.generate_model()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.var_sig_exp_tt" class="doc doc-heading">
            <code class="highlight language-python">var_sig_exp_tt(x, b)</code>

</h2>


    <div class="doc doc-contents ">

        <p>x --&gt;
b --&gt;</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def var_sig_exp_tt(x, b):
    """
    x --&gt;
    b --&gt;
    """
    return 1 / (1 + tt.exp(-tt.exp(b) * x))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_model.var_sig_tt" class="doc doc-heading">
            <code class="highlight language-python">var_sig_tt(x, b)</code>

</h2>


    <div class="doc doc-contents ">

        <p>x --&gt;
b --&gt;</p>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_model.py</code></summary>
              <pre class="highlight"><code class="language-python">def var_sig_tt(x, b):
    """
    x --&gt;
    b --&gt;
    """
    return 1 / (1 + tt.exp(-b * x))</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="preprocessing-functions"><strong>=== Preprocessing functions ===</strong></h2>


<div class="doc doc-object doc-module">



<a id="pytau.changepoint_preprocess"></a>
    <div class="doc doc-contents first">

        <p>Code to preprocess spike trains before feeding into model</p>










  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_preprocess.preprocess_all_taste" class="doc doc-heading">
            <code class="highlight language-python">preprocess_all_taste(spike_array, time_lims, bin_width, data_transform)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Preprocess array containing trials for all tastes (in blocks) concatenated</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spike_array</code>
            </td>
            <td>
                  <code>4D Numpy Array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Taste x Trials x Neurons x Time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>time_lims</code>
            </td>
            <td>
                  <code>List/Tuple/Numpy Array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>2-element object indicating limits of array</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bin_width</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Width to use for binning</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>data_transform</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Data-type to return {actual, shuffled, simulated}</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If transforms do not belong to ['shuffled','simulated','None',None]</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>4D Numpy Array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Of processed data</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_preprocess.py</code></summary>
              <pre class="highlight"><code class="language-python">def preprocess_all_taste(spike_array, time_lims, bin_width, data_transform):
    """Preprocess array containing trials for all tastes (in blocks) concatenated

    Args:
        spike_array (4D Numpy Array): Taste x Trials x Neurons x Time
        time_lims (List/Tuple/Numpy Array): 2-element object indicating limits of array
        bin_width (int): Width to use for binning
        data_transform (str): Data-type to return {actual, shuffled, simulated}

    Raises:
        Exception: If transforms do not belong to ['shuffled','simulated','None',None]

    Returns:
        (4D Numpy Array): Of processed data
    """

    accepted_transforms = [
        "trial_shuffled",
        "spike_shuffled",
        "simulated",
        "None",
        None,
    ]
    if data_transform not in accepted_transforms:
        raise Exception(
            f"data_transform must be of type {accepted_transforms}")

    ##################################################
    # Create shuffled data
    ##################################################
    # Shuffle neurons across trials FOR SAME TASTE

    if data_transform == "trial_shuffled":
        transformed_dat = np.array(
            [np.random.permutation(neuron)
             for neuron in np.swapaxes(spike_array, 2, 0)]
        )
        transformed_dat = np.swapaxes(transformed_dat, 0, 2)

    if data_transform == "spike_shuffled":
        transformed_dat = spike_array.swapaxes(-1, 0)
        transformed_dat = np.stack([np.random.permutation(x)
                                   for x in transformed_dat])
        transformed_dat = transformed_dat.swapaxes(0, -1)

    ##################################################
    # Create simulated data
    ##################################################
    # Inhomogeneous poisson process using mean firing rates

    elif data_transform == "simulated":
        mean_firing = np.mean(spike_array, axis=1)
        mean_firing = np.broadcast_to(mean_firing[:, None], spike_array.shape)

        # Simulate spikes
        transformed_dat = (np.random.random(
            spike_array.shape) &lt; mean_firing) * 1

    ##################################################
    # Null Transform Case
    ##################################################
    elif data_transform == None or data_transform == "None":
        transformed_dat = spike_array

    ##################################################
    # Bin Data
    ##################################################
    spike_binned = np.sum(
        transformed_dat[..., time_lims[0]: time_lims[1]].reshape(
            *transformed_dat.shape[:-1], -1, bin_width
        ),
        axis=-1,
    )
    spike_binned = spike_binned.astype(int)

    return spike_binned</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="pytau.changepoint_preprocess.preprocess_single_taste" class="doc doc-heading">
            <code class="highlight language-python">preprocess_single_taste(spike_array, time_lims, bin_width, data_transform)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Preprocess array containing trials for all tastes (in blocks) concatenated</p>
<p>** Note, it may be useful to use x-arrays here to keep track of coordinates</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>spike_array</code>
            </td>
            <td>
                  <code>3D Numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>trials x neurons x time</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>time_lims</code>
            </td>
            <td>
                  <code>List/Tuple/Numpy Array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>2-element object indicating limits of array</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bin_width</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Width to use for binning</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>data_transform</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Data-type to return
                {actual, trial_shuffled, spike_shuffled, simulated}</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="Exception">Exception</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If transforms do not belong to</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code>3D Numpy Array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Of processed data</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="mkdocstrings-source">
              <summary>Source code in <code>pytau/changepoint_preprocess.py</code></summary>
              <pre class="highlight"><code class="language-python">def preprocess_single_taste(spike_array, time_lims, bin_width, data_transform):
    """Preprocess array containing trials for all tastes (in blocks) concatenated

    ** Note, it may be useful to use x-arrays here to keep track of coordinates

    Args:
        spike_array (3D Numpy array): trials x neurons x time
        time_lims (List/Tuple/Numpy Array): 2-element object indicating limits of array
        bin_width (int): Width to use for binning
        data_transform (str): Data-type to return
                            {actual, trial_shuffled, spike_shuffled, simulated}

    Raises:
        Exception: If transforms do not belong to
        ['trial_shuffled','spike_shuffled','simulated','None',None]

    Returns:
        (3D Numpy Array): Of processed data
    """

    accepted_transforms = [
        "trial_shuffled",
        "spike_shuffled",
        "simulated",
        "None",
        None,
    ]
    if data_transform not in accepted_transforms:
        raise Exception(
            f"data_transform must be of type {accepted_transforms}")

    ##################################################
    # Create shuffled data
    ##################################################
    # Shuffle neurons across trials FOR SAME TASTE

    if data_transform == "trial_shuffled":
        transformed_dat = np.array(
            [np.random.permutation(neuron)
             for neuron in np.swapaxes(spike_array, 1, 0)]
        )
        transformed_dat = np.swapaxes(transformed_dat, 0, 1)

    if data_transform == "spike_shuffled":
        transformed_dat = np.moveaxis(spike_array, -1, 0)
        transformed_dat = np.stack([np.random.permutation(x)
                                   for x in transformed_dat])
        transformed_dat = np.moveaxis(transformed_dat, 0, -1)
    ##################################################
    # Create simulated data
    ##################################################
    # Inhomogeneous poisson process using mean firing rates

    elif data_transform == "simulated":
        mean_firing = np.mean(spike_array, axis=0)

        # Simulate spikes
        transformed_dat = (
            np.array(
                [
                    np.random.random(mean_firing.shape) &lt; mean_firing
                    for trial in range(spike_array.shape[0])
                ]
            )
            * 1
        )

    ##################################################
    # Null Transform Case
    ##################################################
    elif data_transform in (None, "None"):
        transformed_dat = spike_array

    ##################################################
    # Bin Data
    ##################################################
    spike_binned = np.sum(
        transformed_dat[..., time_lims[0]: time_lims[1]].reshape(
            *spike_array.shape[:-1], -1, bin_width
        ),
        axis=-1,
    )
    spike_binned = spike_binned.astype(int)

    return spike_binned</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
